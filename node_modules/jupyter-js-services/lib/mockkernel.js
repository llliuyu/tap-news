// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var utils = require('jupyter-js-utils');
var phosphor_signaling_1 = require('phosphor-signaling');
var kernelfuture_1 = require('./kernelfuture');
var ikernel_1 = require('./ikernel');
var kernel_1 = require('./kernel');
/**
 * A mock kernel object.
 * It only keeps one kernel future at a time.
 */
var MockKernel = (function () {
    function MockKernel(options) {
        var _this = this;
        this.username = '';
        this.clientId = '';
        this._status = ikernel_1.KernelStatus.Unknown;
        this._isDisposed = false;
        this._future = null;
        this._kernelspec = null;
        this._kernelInfo = null;
        this._executionCount = 0;
        options = options || {};
        this.id = options.id || '';
        this.name = options.name || 'python';
        Promise.resolve().then(function () {
            _this._changeStatus(ikernel_1.KernelStatus.Idle);
        });
    }
    Object.defineProperty(MockKernel.prototype, "statusChanged", {
        /**
         * A signal emitted when the kernel status changes.
         */
        get: function () {
            return Private.statusChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockKernel.prototype, "iopubMessage", {
        /**
         * A signal emitted for iopub kernel messages.
         */
        get: function () {
            return Private.iopubMessageSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockKernel.prototype, "unhandledMessage", {
        /**
         * A signal emitted for unhandled kernel message.
         */
        get: function () {
            return Private.unhandledMessageSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockKernel.prototype, "status", {
        /**
         * The current status of the kernel.
         */
        get: function () {
            return this._status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockKernel.prototype, "isDisposed", {
        /**
         * Test whether the kernel has been disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the kernel.
     */
    MockKernel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._isDisposed = true;
    };
    /**
     * Send a shell message to the kernel.
     */
    MockKernel.prototype.sendShellMessage = function (msg, expectReply, disposeOnDone) {
        if (expectReply === void 0) { expectReply = false; }
        if (disposeOnDone === void 0) { disposeOnDone = true; }
        var future = new kernelfuture_1.KernelFutureHandler(function () { }, msg, expectReply, disposeOnDone);
        this._future = future;
        return future;
    };
    /**
     * Send a message to the kernel.
     */
    MockKernel.prototype.sendServerMessage = function (msgType, channel, contents) {
        var future = this._future;
        if (!future) {
            return;
        }
        var options = {
            msgType: msgType,
            channel: channel,
            username: this.username,
            session: this.clientId
        };
        var msg = kernel_1.createKernelMessage(options, contents);
        future.handleMsg(msg);
    };
    /**
     * Send a shell reply message to the kernel.
     */
    MockKernel.prototype.sendShellReply = function (contents) {
        var future = this._future;
        if (!future) {
            return;
        }
        var msgType = future.msg.header.msg_type.replace('_request', '_reply');
        this.sendServerMessage(msgType, 'shell', contents);
    };
    /**
     * Interrupt a kernel.
     */
    MockKernel.prototype.interrupt = function () {
        var _this = this;
        return Promise.resolve().then(function () {
            _this._changeStatus(ikernel_1.KernelStatus.Idle);
        });
    };
    /**
     * Restart a kernel.
     */
    MockKernel.prototype.restart = function () {
        var _this = this;
        this._changeStatus(ikernel_1.KernelStatus.Restarting);
        return Promise.resolve().then(function () {
            _this._changeStatus(ikernel_1.KernelStatus.Idle);
        });
    };
    /**
     * Shutdown a kernel.
     */
    MockKernel.prototype.shutdown = function () {
        this._changeStatus(ikernel_1.KernelStatus.Dead);
        this.dispose();
        return Promise.resolve(void 0);
    };
    /**
     * Send a `kernel_info_request` message.
     */
    MockKernel.prototype.kernelInfo = function () {
        return Promise.resolve(this._kernelInfo);
    };
    /**
     * Set the kernel info for the mock kernel.
     */
    MockKernel.prototype.setKernelInfo = function (value) {
        this._kernelInfo = value;
    };
    /**
     * Send a `complete_request` message.
     */
    MockKernel.prototype.complete = function (contents) {
        return this._sendKernelMessage('complete_request', 'shell', contents);
    };
    /**
     * Send a `history_request` message.
     */
    MockKernel.prototype.history = function (contents) {
        return this._sendKernelMessage('history', 'shell', contents);
    };
    /**
     * Send an `inspect_request` message.
     */
    MockKernel.prototype.inspect = function (contents) {
        return this._sendKernelMessage('inspect_request', 'shell', contents);
    };
    /**
     * Send an `execute_request` message.
     *
     * #### Notes
     * This simulatates an actual exection on the server.
     */
    MockKernel.prototype.execute = function (contents, disposeOnDone) {
        var _this = this;
        if (disposeOnDone === void 0) { disposeOnDone = true; }
        var options = {
            msgType: 'execute_request',
            channel: 'shell',
            username: '',
            session: ''
        };
        var defaults = {
            silent: false,
            store_history: true,
            user_expressions: {},
            allow_stdin: true,
            stop_on_error: false
        };
        contents = utils.extend(defaults, contents);
        var msg = kernel_1.createKernelMessage(options, contents);
        var future = this.sendShellMessage(msg, true, disposeOnDone);
        Promise.resolve(void 0).then(function () {
            _this.sendServerMessage('status', 'iopub', {
                execution_state: 'busy'
            });
            _this.sendServerMessage('stream', 'iopub', {
                name: 'stdout',
                text: 'foo'
            });
            _this.sendServerMessage('status', 'iopub', {
                execution_state: 'idle'
            });
            _this.sendServerMessage('execute_reply', 'shell', {
                execution_count: ++_this._executionCount,
                data: {},
                metadata: {}
            });
        });
        return future;
    };
    /**
     * Send an `is_complete_request` message.
     */
    MockKernel.prototype.isComplete = function (contents) {
        return this._sendKernelMessage('is_complete_request', 'shell', contents);
    };
    /**
     * Send a `comm_info_request` message.
     */
    MockKernel.prototype.commInfo = function (contents) {
        return this._sendKernelMessage('comm_info_request', 'shell', contents);
    };
    /**
     * Send an `input_reply` message.
     */
    MockKernel.prototype.sendInputReply = function (contents) { };
    /**
     * Register a comm target handler.
     */
    MockKernel.prototype.registerCommTarget = function (targetName, callback) {
        return void 0;
    };
    /**
     * Connect to a comm, or create a new one.
     */
    MockKernel.prototype.connectToComm = function (targetName, commId) {
        return void 0;
    };
    /**
     * Get the kernel spec associated with the kernel.
     */
    MockKernel.prototype.getKernelSpec = function () {
        return Promise.resolve(this._kernelspec);
    };
    /**
     * Set the kernel spec associated with the kernel.
     */
    MockKernel.prototype.setKernelSpec = function (value) {
        this._kernelspec = value;
    };
    MockKernel.prototype._sendKernelMessage = function (msgType, channel, contents) {
        var options = {
            msgType: msgType,
            channel: channel,
            username: this.username,
            session: this.clientId
        };
        var msg = kernel_1.createKernelMessage(options, contents);
        var future;
        try {
            future = this.sendShellMessage(msg, true);
        }
        catch (e) {
            return Promise.reject(e);
        }
        return new Promise(function (resolve, reject) {
            future.onReply = function (reply) {
                resolve(reply.content);
            };
        });
    };
    MockKernel.prototype._changeStatus = function (status) {
        if (this._status === status) {
            return;
        }
        this._status = status;
        this.statusChanged.emit(status);
    };
    return MockKernel;
}());
exports.MockKernel = MockKernel;
var Private;
(function (Private) {
    /**
     * A signal emitted when the kernel status changes.
     */
    Private.statusChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted for iopub kernel messages.
     */
    Private.iopubMessageSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted for unhandled kernel message.
     */
    Private.unhandledMessageSignal = new phosphor_signaling_1.Signal();
})(Private || (Private = {}));
