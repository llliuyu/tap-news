import { IDisposable } from 'phosphor-disposable';
import { ISignal } from 'phosphor-signaling';
import { IComm, ICommInfoRequest, ICommInfoReply, ICompleteReply, ICompleteRequest, IExecuteRequest, IInspectReply, IInspectRequest, IIsCompleteReply, IIsCompleteRequest, IInputReply, IKernel, IKernelFuture, IKernelId, IKernelInfo, IKernelMessage, KernelStatus, IKernelIOPubCommOpenMessage, IKernelSpec, IHistoryRequest, IHistoryReply } from './ikernel';
/**
 * A mock kernel object.
 * It only keeps one kernel future at a time.
 */
export declare class MockKernel implements IKernel {
    id: string;
    name: string;
    username: string;
    clientId: string;
    constructor(options?: IKernelId);
    /**
     * A signal emitted when the kernel status changes.
     */
    statusChanged: ISignal<IKernel, KernelStatus>;
    /**
     * A signal emitted for iopub kernel messages.
     */
    iopubMessage: ISignal<IKernel, IKernelMessage>;
    /**
     * A signal emitted for unhandled kernel message.
     */
    unhandledMessage: ISignal<IKernel, IKernelMessage>;
    /**
     * The current status of the kernel.
     */
    status: KernelStatus;
    /**
     * Test whether the kernel has been disposed.
     */
    isDisposed: boolean;
    /**
     * Dispose of the resources held by the kernel.
     */
    dispose(): void;
    /**
     * Send a shell message to the kernel.
     */
    sendShellMessage(msg: IKernelMessage, expectReply?: boolean, disposeOnDone?: boolean): IKernelFuture;
    /**
     * Send a message to the kernel.
     */
    sendServerMessage(msgType: string, channel: string, contents: any): void;
    /**
     * Send a shell reply message to the kernel.
     */
    sendShellReply(contents: any): void;
    /**
     * Interrupt a kernel.
     */
    interrupt(): Promise<void>;
    /**
     * Restart a kernel.
     */
    restart(): Promise<void>;
    /**
     * Shutdown a kernel.
     */
    shutdown(): Promise<void>;
    /**
     * Send a `kernel_info_request` message.
     */
    kernelInfo(): Promise<IKernelInfo>;
    /**
     * Set the kernel info for the mock kernel.
     */
    setKernelInfo(value: IKernelInfo): void;
    /**
     * Send a `complete_request` message.
     */
    complete(contents: ICompleteRequest): Promise<ICompleteReply>;
    /**
     * Send a `history_request` message.
     */
    history(contents: IHistoryRequest): Promise<IHistoryReply>;
    /**
     * Send an `inspect_request` message.
     */
    inspect(contents: IInspectRequest): Promise<IInspectReply>;
    /**
     * Send an `execute_request` message.
     *
     * #### Notes
     * This simulatates an actual exection on the server.
     */
    execute(contents: IExecuteRequest, disposeOnDone?: boolean): IKernelFuture;
    /**
     * Send an `is_complete_request` message.
     */
    isComplete(contents: IIsCompleteRequest): Promise<IIsCompleteReply>;
    /**
     * Send a `comm_info_request` message.
     */
    commInfo(contents: ICommInfoRequest): Promise<ICommInfoReply>;
    /**
     * Send an `input_reply` message.
     */
    sendInputReply(contents: IInputReply): void;
    /**
     * Register a comm target handler.
     */
    registerCommTarget(targetName: string, callback: (comm: IComm, msg: IKernelIOPubCommOpenMessage) => void): IDisposable;
    /**
     * Connect to a comm, or create a new one.
     */
    connectToComm(targetName: string, commId?: string): IComm;
    /**
     * Get the kernel spec associated with the kernel.
     */
    getKernelSpec(): Promise<IKernelSpec>;
    /**
     * Set the kernel spec associated with the kernel.
     */
    setKernelSpec(value: IKernelSpec): void;
    private _sendKernelMessage(msgType, channel, contents);
    private _changeStatus(status);
    private _status;
    private _isDisposed;
    private _future;
    private _kernelspec;
    private _kernelInfo;
    private _executionCount;
}
