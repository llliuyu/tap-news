// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_observablelist_1 = require('phosphor-observablelist');
var nbformat_1 = require('../notebook/nbformat');
/**
 * An observable list that handles output area data.
 */
var ObservableOutputs = (function (_super) {
    __extends(ObservableOutputs, _super);
    function ObservableOutputs() {
        _super.apply(this, arguments);
        this._clearNext = false;
    }
    /**
     * Add an output, which may be combined with previous output
     * (e.g. for streams).
     */
    ObservableOutputs.prototype.add = function (output) {
        // If we received a delayed clear message, then clear now.
        if (this._clearNext) {
            this.clear();
            this._clearNext = false;
        }
        // Consolidate outputs if they are stream outputs of the same kind.
        var index = this.length - 1;
        var lastOutput = this.get(index);
        if (nbformat_1.nbformat.isStream(output)
            && lastOutput && nbformat_1.nbformat.isStream(lastOutput)
            && output.name === lastOutput.name) {
            // In order to get a list change event, we add the previous
            // text to the current item and replace the previous item.
            // This also replaces the metadata of the last item.
            var text = output.text;
            output.text = lastOutput.text + text;
            this.set(index, output);
            return index;
        }
        else {
            switch (output.output_type) {
                case 'stream':
                case 'execute_result':
                case 'display_data':
                case 'error':
                    return _super.prototype.add.call(this, output);
                default:
                    break;
            }
        }
        return -1;
    };
    /**
     * Clear all of the output.
     *
     * @param wait Delay clearing the output until the next message is added.
     */
    ObservableOutputs.prototype.clear = function (wait) {
        if (wait === void 0) { wait = false; }
        if (wait) {
            this._clearNext = true;
            return [];
        }
        return _super.prototype.clear.call(this);
    };
    return ObservableOutputs;
}(phosphor_observablelist_1.ObservableList));
exports.ObservableOutputs = ObservableOutputs;
/**
 * Execute code on a kernel and send outputs to an observable output.
 */
function executeCode(code, kernel, outputs) {
    var exRequest = {
        code: code,
        silent: false,
        store_history: true,
        stop_on_error: true,
        allow_stdin: true
    };
    outputs.clear();
    return new Promise(function (resolve, reject) {
        var future = kernel.execute(exRequest);
        future.onIOPub = (function (msg) {
            var model = msg.content;
            if (model !== void 0) {
                model.output_type = msg.header.msg_type;
                outputs.add(model);
            }
        });
        future.onReply = (function (msg) {
            resolve(msg.content);
        });
    });
}
exports.executeCode = executeCode;
