// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var dialog_1 = require('jupyter-js-ui/lib/dialog');
var phosphor_panel_1 = require('phosphor-panel');
var phosphor_widget_1 = require('phosphor-widget');
var completion_1 = require('../completion');
var toolbar_1 = require('./toolbar');
var widget_1 = require('./widget');
/**
 * The class name added to notebook panels.
 */
var NB_PANEL = 'jp-Notebook-panel';
/**
 * The class name added to notebook container widgets.
 */
var NB_CONTAINER = 'jp-Notebook-container';
/**
 * The class name added to a dirty widget.
 */
var DIRTY_CLASS = 'jp-mod-dirty';
/**
 * A widget that hosts a notebook toolbar and content area.
 *
 * #### Notes
 * The widget keeps the document metadata in sync with the current
 * kernel on the context.
 */
var NotebookPanel = (function (_super) {
    __extends(NotebookPanel, _super);
    /**
     * Construct a new notebook panel.
     */
    function NotebookPanel(model, rendermime, context, clipboard) {
        var _this = this;
        _super.call(this);
        this._rendermime = null;
        this._context = null;
        this._model = null;
        this._content = null;
        this._toolbar = null;
        this._clipboard = null;
        this._completion = null;
        this._pendingComplete = 0;
        this.addClass(NB_PANEL);
        this._model = model;
        this._rendermime = rendermime;
        this._context = context;
        this._clipboard = clipboard;
        context.kernelChanged.connect(function () {
            _this.handleKernelChange(context.kernel);
        });
        if (context.kernel) {
            this.handleKernelChange(context.kernel);
        }
        this.layout = new phosphor_panel_1.PanelLayout();
        var ctor = this.constructor;
        this._content = ctor.createContent(model, rendermime);
        this._toolbar = ctor.createToolbar();
        var container = new phosphor_panel_1.Panel();
        container.addClass(NB_CONTAINER);
        container.addChild(this._content);
        var layout = this.layout;
        layout.addChild(this._toolbar);
        layout.addChild(container);
        // Instantiate tab completion widget.
        this._completion = ctor.createCompletion();
        this._completion.reference = this;
        this._completion.attach(document.body);
        this._completion.selected.connect(this.onCompletionSelect, this);
        // Connect signals.
        this._content.stateChanged.connect(this.onContentChanged, this);
        var cell = this._content.childAt(this._content.activeCellIndex);
        if (cell) {
            var editor = cell.editor;
            editor.textChanged.connect(this.onTextChange, this);
            editor.completionRequested.connect(this.onCompletionRequest, this);
        }
        // Handle the document title.
        this.title.text = context.path.split('/').pop();
        context.pathChanged.connect(function (c, path) {
            _this.title.text = path.split('/').pop();
        });
        // Handle changes to dirty state.
        model.stateChanged.connect(function (m, args) {
            if (args.name === 'dirty') {
                if (args.newValue) {
                    _this.title.className += " " + DIRTY_CLASS;
                }
                else {
                    _this.title.className = _this.title.className.replace(DIRTY_CLASS, '');
                }
            }
        });
    }
    /**
     * Create a new content area for the notebook.
     */
    NotebookPanel.createContent = function (model, rendermime) {
        return new widget_1.ActiveNotebook(model, rendermime);
    };
    /**
     * Create a new toolbar for the notebook.
     */
    NotebookPanel.createToolbar = function () {
        return new toolbar_1.NotebookToolbar();
    };
    /**
     * Create a new completion widget.
     */
    NotebookPanel.createCompletion = function () {
        var model = new completion_1.CompletionModel();
        return new completion_1.CompletionWidget(model);
    };
    Object.defineProperty(NotebookPanel.prototype, "toolbar", {
        /**
         * Get the toolbar used by the widget.
         */
        get: function () {
            return this._toolbar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookPanel.prototype, "content", {
        /**
         * Get the content area used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookPanel.prototype, "rendermime", {
        /**
         * Get the rendermime instance used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._rendermime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookPanel.prototype, "clipboard", {
        /**
         * Get the clipboard instance used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._clipboard;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookPanel.prototype, "model", {
        /**
         * Get the model used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookPanel.prototype, "context", {
        /**
         * Get the document context for the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources used by the widget.
     */
    NotebookPanel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._context = null;
        this._rendermime = null;
        this._content = null;
        this._toolbar = null;
        this._clipboard = null;
        this._completion.dispose();
        this._completion = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Restart the kernel on the panel.
     */
    NotebookPanel.prototype.restart = function () {
        var kernel = this.context.kernel;
        if (!kernel) {
            return Promise.resolve(false);
        }
        return dialog_1.showDialog({
            title: 'Restart Kernel?',
            body: 'Do you want to restart the current kernel? All variables will be lost.',
            host: this.node
        }).then(function (result) {
            if (result.text === 'OK') {
                return kernel.restart().then(function () { return true; });
            }
            else {
                return false;
            }
        });
    };
    /**
     * Handle a change in the kernel by updating the document metadata.
     */
    NotebookPanel.prototype.handleKernelChange = function (kernel) {
        var _this = this;
        kernel.kernelInfo().then(function (info) {
            var infoCursor = _this.model.getMetadata('language_info');
            infoCursor.setValue(info.language_info);
        });
        kernel.getKernelSpec().then(function (spec) {
            var specCursor = _this.model.getMetadata('kernelspec');
            specCursor.setValue({
                name: kernel.name,
                display_name: spec.display_name,
                language: spec.language
            });
        });
    };
    /**
     * Handle a change in the content area.
     */
    NotebookPanel.prototype.onContentChanged = function (sender, args) {
        switch (args.name) {
            case 'activeCellIndex':
                var cell = this._content.childAt(args.oldValue);
                var editor = cell.editor;
                editor.textChanged.disconnect(this.onTextChange, this);
                editor.completionRequested.disconnect(this.onCompletionRequest, this);
                cell = this._content.childAt(args.newValue);
                editor = cell.editor;
                editor.textChanged.connect(this.onTextChange, this);
                editor.completionRequested.connect(this.onCompletionRequest, this);
                break;
            default:
                break;
        }
    };
    /**
     * Handle a text changed signal from an editor.
     */
    NotebookPanel.prototype.onTextChange = function (editor, change) {
        var line = change.newValue.split('\n')[change.line];
        var model = this._completion.model;
        // If last character entered is not whitespace, update completion.
        if (line[change.ch - 1] && line[change.ch - 1].match(/\S/)) {
            // If there is currently a completion
            if (model.original) {
                model.current = change;
            }
        }
        else {
            // If final character is whitespace, reset completion.
            model.options = null;
            model.original = null;
            model.cursor = null;
            return;
        }
    };
    /**
     * Handle a completion requested signal from an editor.
     */
    NotebookPanel.prototype.onCompletionRequest = function (editor, change) {
        var _this = this;
        var kernel = this.context.kernel;
        if (!kernel) {
            return;
        }
        var contents = {
            // Only send the current line of code for completion.
            code: change.currentValue.split('\n')[change.line],
            cursor_pos: change.ch
        };
        var pendingComplete = ++this._pendingComplete;
        var model = this._completion.model;
        kernel.complete(contents).then(function (value) {
            // If model has been disposed, bail.
            if (model.isDisposed) {
                return;
            }
            // If a newer completion requesy has created a pending request, bail.
            if (pendingComplete !== _this._pendingComplete) {
                return;
            }
            // Completion request failures or negative results fail silently.
            if (value.status !== 'ok') {
                return;
            }
            // Update the model.
            model.options = value.matches;
            model.cursor = { start: value.cursor_start, end: value.cursor_end };
        }).then(function () {
            model.original = change;
        });
    };
    /**
     * Handle a completion selected signal from the completion widget.
     */
    NotebookPanel.prototype.onCompletionSelect = function (widget, value) {
        var patch = this._completion.model.createPatch(value);
        var cell = this._content.childAt(this._content.activeCellIndex);
        var editor = cell.editor.editor;
        var doc = editor.getDoc();
        doc.setValue(patch.text);
        doc.setCursor(doc.posFromIndex(patch.position));
    };
    return NotebookPanel;
}(phosphor_widget_1.Widget));
exports.NotebookPanel = NotebookPanel;
