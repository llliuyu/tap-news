// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var utils = require('jupyter-js-utils');
var phosphor_observablelist_1 = require('phosphor-observablelist');
var phosphor_signaling_1 = require('phosphor-signaling');
var model_1 = require('../cells/model');
var json_1 = require('../common/json');
var metadata_1 = require('../common/metadata');
var undo_1 = require('../common/undo');
var nbformat_1 = require('./nbformat');
/**
 * An implementation of a notebook Model.
 */
var NotebookModel = (function () {
    /**
     * Construct a new notebook model.
     */
    function NotebookModel(languagePreference) {
        var _this = this;
        this._cells = null;
        this._metadata = Private.createMetadata();
        this._dirty = false;
        this._readOnly = false;
        this._cursors = Object.create(null);
        this._nbformat = nbformat_1.nbformat.MAJOR_VERSION;
        this._nbformatMinor = nbformat_1.nbformat.MINOR_VERSION;
        this._cells = new undo_1.OberservableUndoableList(function (data) {
            switch (data.cell_type) {
                case 'code':
                    return _this.createCodeCell(data);
                case 'markdown':
                    return _this.createMarkdownCell(data);
                default:
                    return _this.createRawCell(data);
            }
        });
        this._cells.changed.connect(this.onCellsChanged, this);
        if (languagePreference) {
            this._metadata['language_info'] = "{\"name\":\"" + languagePreference + "\"}";
        }
    }
    Object.defineProperty(NotebookModel.prototype, "contentChanged", {
        /**
         * A signal emitted when the document content changes.
         */
        get: function () {
            return Private.contentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "stateChanged", {
        /**
         * A signal emitted when a model state changes.
         */
        get: function () {
            return Private.stateChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "metadataChanged", {
        /**
         * A signal emitted when a metadata field changes.
         */
        get: function () {
            return Private.metadataChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "cells", {
        /**
         * Get the observable list of notebook cells.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._cells;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "nbformat", {
        /**
         * The major version number of the nbformat.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._nbformat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "nbformatMinor", {
        /**
         * The minor version number of the nbformat.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._nbformatMinor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "dirty", {
        /**
         * The dirty state of the model.
         *
         * #### Notes
         * This should be cleared when the document is loaded from
         * or saved to disk.
         */
        get: function () {
            return this._dirty;
        },
        set: function (newValue) {
            if (newValue === this._dirty) {
                return;
            }
            var oldValue = this._dirty;
            this._dirty = newValue;
            this.stateChanged.emit({ name: 'dirty', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "readOnly", {
        /**
         * The read-only state of the model.
         */
        get: function () {
            return this._readOnly;
        },
        set: function (newValue) {
            if (newValue === this._readOnly) {
                return;
            }
            var oldValue = this._readOnly;
            this._readOnly = newValue;
            this.stateChanged.emit({ name: 'readOnly', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "defaultKernelName", {
        /**
         * The default kernel name of the document.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var spec = this._metadata['kernelspec'];
            return spec ? spec.name : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "defaultKernelLanguage", {
        /**
         * The default kernel language of the document.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var info = this._metadata['language_info'];
            return info ? info.name : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._cells === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    NotebookModel.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        var cells = this._cells;
        cells.dispose();
        phosphor_signaling_1.clearSignalData(this);
        for (var i = 0; i < cells.length; i++) {
            var cell = cells.get(i);
            cell.dispose();
        }
        cells.clear();
        this._cells = null;
        for (var key in this._cursors) {
            this._cursors[key].dispose();
        }
        this._cursors = null;
        this._metadata = null;
    };
    /**
     * Serialize the model to a string.
     */
    NotebookModel.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    /**
     * Deserialize the model from a string.
     *
     * #### Notes
     * Should emit a [contentChanged] signal.
     */
    NotebookModel.prototype.fromString = function (value) {
        this.fromJSON(JSON.parse(value));
    };
    /**
     * Serialize the model to JSON.
     */
    NotebookModel.prototype.toJSON = function () {
        var cells = [];
        for (var i = 0; i < this.cells.length; i++) {
            var cell = this.cells.get(i);
            cells.push(cell.toJSON());
        }
        var metadata = utils.copy(this._metadata);
        return {
            metadata: metadata,
            nbformat_minor: this._nbformatMinor,
            nbformat: this._nbformat,
            cells: cells
        };
    };
    /**
     * Deserialize the model from JSON.
     *
     * #### Notes
     * Should emit a [contentChanged] signal.
     */
    NotebookModel.prototype.fromJSON = function (value) {
        var cells = [];
        for (var _i = 0, _a = value.cells; _i < _a.length; _i++) {
            var data = _a[_i];
            switch (data.cell_type) {
                case 'code':
                    cells.push(new model_1.CodeCellModel(data));
                    break;
                case 'markdown':
                    cells.push(new model_1.MarkdownCellModel(data));
                    break;
                case 'raw':
                    cells.push(new model_1.RawCellModel(data));
                    break;
                default:
                    continue;
            }
        }
        this.cells.assign(cells);
        var oldValue = 0;
        var newValue = 0;
        if (value.nbformat !== this._nbformat) {
            oldValue = this._nbformat;
            this._nbformat = newValue = value.nbformat;
            this.stateChanged.emit({ name: 'nbformat', oldValue: oldValue, newValue: newValue });
        }
        if (value.nbformat_minor !== this._nbformatMinor) {
            oldValue = this._nbformat;
            this._nbformatMinor = newValue = value.nbformat_minor;
            this.stateChanged.emit({ name: 'nbformatMinor', oldValue: oldValue, newValue: newValue });
        }
        // Update the metadata.
        var metadata = value.metadata;
        var builtins = ['kernelspec', 'language_info', 'orig_nbformat'];
        for (var key in this._metadata) {
            if (builtins.indexOf(key) !== -1) {
                continue;
            }
            if (!(key in metadata)) {
                this.setCursorData(key, null);
                delete this._metadata[key];
                if (this._cursors[key]) {
                    this._cursors[key].dispose();
                    delete this._cursors[key];
                }
            }
        }
        for (var key in metadata) {
            this.setCursorData(key, metadata[key]);
        }
        this.dirty = true;
    };
    /**
     * Initialize the model state.
     */
    NotebookModel.prototype.initialize = function () {
        this._cells.clearUndo();
        this.dirty = false;
    };
    /**
     * A factory for creating a new code cell.
     *
     * @param source - The data to use for the original source data.
     *
     * @returns A new code cell. If a source cell is provided, the
     *   new cell will be intialized with the data from the source.
     *
     * #### Notes
     * If the source argument does not give an input mimetype, the code cell
     * defaults to the notebook [[defaultMimetype]].
     */
    NotebookModel.prototype.createCodeCell = function (source) {
        return new model_1.CodeCellModel(source);
    };
    /**
     * A factory for creating a new Markdown cell.
     *
     * @param source - The data to use for the original source data.
     *
     * @returns A new markdown cell. If a source cell is provided, the
     *   new cell will be intialized with the data from the source.
     */
    NotebookModel.prototype.createMarkdownCell = function (source) {
        return new model_1.MarkdownCellModel(source);
    };
    /**
     * A factory for creating a new raw cell.
     *
     * @param source - The data to use for the original source data.
     *
     * @returns A new raw cell. If a source cell is provided, the
     *   new cell will be intialized with the data from the source.
     */
    NotebookModel.prototype.createRawCell = function (source) {
        return new model_1.RawCellModel(source);
    };
    /**
     * Get a metadata cursor for the notebook.
     *
     * #### Notes
     * Metadata associated with the nbformat spec are set directly
     * on the model.  This method is used to interact with a namespaced
     * set of metadata on the notebook.
     */
    NotebookModel.prototype.getMetadata = function (name) {
        var _this = this;
        if (name in this._cursors) {
            return this._cursors[name];
        }
        var cursor = new metadata_1.MetadataCursor(name, function () {
            return _this._metadata[name];
        }, function (value) {
            _this.setCursorData(name, value);
        });
        this._cursors[name] = cursor;
        return cursor;
    };
    /**
     * List the metadata namespace keys for the notebook.
     */
    NotebookModel.prototype.listMetadata = function () {
        return Object.keys(this._metadata);
    };
    /**
     * Handle a change in the cells list.
     */
    NotebookModel.prototype.onCellsChanged = function (list, change) {
        var cell;
        switch (change.type) {
            case phosphor_observablelist_1.ListChangeType.Add:
                cell = change.newValue;
                cell.contentChanged.connect(this.onCellChanged, this);
                break;
            case phosphor_observablelist_1.ListChangeType.Remove:
                change.oldValue.dispose();
                break;
            case phosphor_observablelist_1.ListChangeType.Replace:
                var newValues = change.newValue;
                for (var _i = 0, newValues_1 = newValues; _i < newValues_1.length; _i++) {
                    cell = newValues_1[_i];
                    cell.contentChanged.connect(this.onCellChanged, this);
                }
                var oldValues = change.oldValue;
                for (var _a = 0, oldValues_1 = oldValues; _a < oldValues_1.length; _a++) {
                    cell = oldValues_1[_a];
                    cell.dispose();
                }
                break;
            case phosphor_observablelist_1.ListChangeType.Set:
                cell = change.newValue;
                cell.contentChanged.connect(this.onCellChanged, this);
                if (change.oldValue) {
                    change.oldValue.dispose();
                }
                break;
            default:
                return;
        }
        this.dirty = true;
    };
    /**
     * Handle a change to a cell state.
     */
    NotebookModel.prototype.onCellChanged = function (cell, change) {
        this.dirty = true;
        this.contentChanged.emit(void 0);
    };
    /**
     * Set the cursor data for a given field.
     */
    NotebookModel.prototype.setCursorData = function (name, newValue) {
        var oldValue = this._metadata[name];
        if (json_1.deepEqual(oldValue, newValue)) {
            return;
        }
        this._metadata[name] = newValue;
        this.dirty = true;
        this.contentChanged.emit(void 0);
        this.metadataChanged.emit({ name: name, oldValue: oldValue, newValue: newValue });
    };
    return NotebookModel;
}());
exports.NotebookModel = NotebookModel;
/**
 * A private namespace for notebook model data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when the content of the model changes.
     */
    Private.contentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a model state changes.
     */
    Private.stateChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a metadata field changes.
     */
    Private.metadataChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * Create the default metadata for the notebook.
     */
    function createMetadata() {
        return {
            kernelspec: { name: 'unknown', display_name: 'Unknown' },
            language_info: { name: 'unknown' },
            orig_nbformat: 1
        };
    }
    Private.createMetadata = createMetadata;
})(Private || (Private = {}));
