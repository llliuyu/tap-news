// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var cells_1 = require('../cells');
/**
 * The mimetype used for Jupyter cell data.
 */
var JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';
/**
 * A namespace for handling actions on a notebook.
 */
var NotebookActions;
(function (NotebookActions) {
    /**
     * Split the active cell into two cells.
     */
    function splitCell(widget) {
        Private.deselectCells(widget);
        var nbModel = widget.model;
        var index = widget.activeCellIndex;
        var child = widget.childAt(index);
        var position = child.editor.getCursorPosition();
        var orig = child.model.source;
        // Create new models to preserve history.
        var clone0 = Private.cloneCell(nbModel, child.model);
        var clone1 = Private.cloneCell(nbModel, child.model);
        if (clone0.type === 'code') {
            clone0.outputs.clear();
        }
        clone0.source = orig.slice(0, position);
        clone1.source = orig.slice(position).replace(/^\s+/g, '');
        // Make the changes while preserving history.
        nbModel.cells.replace(index, 1, [clone0, clone1]);
        widget.activeCellIndex++;
    }
    NotebookActions.splitCell = splitCell;
    /**
     * Merge selected cells.
     */
    function mergeCells(widget) {
        var toMerge = [];
        var toDelete = [];
        var model = widget.model;
        var cells = model.cells;
        var index = widget.activeCellIndex;
        var primary = widget.childAt(widget.activeCellIndex);
        var child;
        if (!primary) {
            return;
        }
        // Get the other cells to merge.
        for (var i = 0; i < widget.childCount(); i++) {
            if (i === index) {
                continue;
            }
            child = widget.childAt(i);
            if (widget.isSelected(child)) {
                toMerge.push(child.model.source);
                toDelete.push(child.model);
            }
        }
        // Make sure there are cells to merge and select cells.
        if (!toMerge.length) {
            // Choose the cell after the active cell.
            child = widget.childAt(cells.length - 1);
            if (!child) {
                return;
            }
            toMerge.push(child.model.source);
            toDelete.push(child.model);
        }
        Private.deselectCells(widget);
        // Create a new cell for the source to preserve history.
        var newModel = Private.cloneCell(model, primary.model);
        newModel.source += toMerge.join('\n\n');
        if (newModel instanceof cells_1.CodeCellModel) {
            newModel.outputs.clear();
        }
        // Make the changes while preserving history.
        model.cells.beginCompoundOperation();
        cells.set(index, newModel);
        for (var _i = 0, toDelete_1 = toDelete; _i < toDelete_1.length; _i++) {
            var cell = toDelete_1[_i];
            cells.remove(cell);
        }
        model.cells.endCompoundOperation();
        // If the original cell is a markdown cell, make sure it is unrendered.
        if (primary instanceof cells_1.MarkdownCellWidget) {
            var current = widget.childAt(index);
            current.rendered = false;
        }
    }
    NotebookActions.mergeCells = mergeCells;
    /**
     * Delete the selected cells.
     */
    function deleteCells(widget) {
        var model = widget.model;
        var cells = model.cells;
        // Delete the cells as one undo event.
        model.cells.beginCompoundOperation();
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            if (widget.isSelected(child)) {
                var cell = cells.get(i);
                cells.remove(cell);
            }
        }
        if (!model.cells.length) {
            var cell = model.createCodeCell();
            model.cells.add(cell);
        }
        model.cells.endCompoundOperation();
        Private.deselectCells(widget);
    }
    NotebookActions.deleteCells = deleteCells;
    /**
     * Insert a new code cell above the current cell.
     */
    function insertAbove(widget) {
        var cell = widget.model.createCodeCell();
        widget.model.cells.insert(widget.activeCellIndex, cell);
        Private.deselectCells(widget);
    }
    NotebookActions.insertAbove = insertAbove;
    /**
     * Insert a node code cell below the current cell.
     */
    function insertBelow(widget) {
        var cell = widget.model.createCodeCell();
        widget.model.cells.insert(widget.activeCellIndex + 1, cell);
        Private.deselectCells(widget);
    }
    NotebookActions.insertBelow = insertBelow;
    /**
     * Change the selected cell type(s).
     */
    function changeCellType(widget, value) {
        var model = widget.model;
        model.cells.beginCompoundOperation();
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            if (!widget.isSelected(child)) {
                continue;
            }
            if (child.model.type === value) {
                continue;
            }
            var newCell = void 0;
            switch (value) {
                case 'code':
                    newCell = model.createCodeCell(child.model.toJSON());
                    break;
                case 'markdown':
                    newCell = model.createMarkdownCell(child.model.toJSON());
                    break;
                default:
                    newCell = model.createRawCell(child.model.toJSON());
            }
            model.cells.replace(i, 1, [newCell]);
            if (value === 'markdown') {
                // Fetch the new widget and unrender it.
                child = widget.childAt(i);
                child.rendered = false;
            }
        }
        model.cells.endCompoundOperation();
        Private.deselectCells(widget);
    }
    NotebookActions.changeCellType = changeCellType;
    /**
     * Run the selected cell(s).
     */
    function run(widget, kernel) {
        var selected = [];
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            if (widget.isSelected(child)) {
                selected.push(child);
            }
        }
        for (var _i = 0, selected_1 = selected; _i < selected_1.length; _i++) {
            var child = selected_1[_i];
            Private.runCell(child, kernel);
        }
        if (widget.mode === 'command') {
            widget.node.focus();
        }
        else {
            var active = widget.childAt(widget.activeCellIndex);
            active.focus();
        }
    }
    NotebookActions.run = run;
    /**
     * Run the selected cell(s) and advance to the next cell.
     *
     * #### Notes
     * If the last cell is run, a new code cell will be created in
     * edit mode and selected.
     */
    function runAndAdvance(widget, kernel) {
        run(widget, kernel);
        var model = widget.model;
        if (widget.activeCellIndex === widget.childCount() - 1) {
            var cell = model.createCodeCell();
            model.cells.add(cell);
            widget.mode = 'edit';
        }
        else {
            widget.mode = 'command';
        }
        widget.activeCellIndex++;
        Private.deselectCells(widget);
    }
    NotebookActions.runAndAdvance = runAndAdvance;
    /**
     * Run the selected cell(s) and insert a new code cell below in edit mode.
     */
    function runAndInsert(widget, kernel) {
        run(widget, kernel);
        var model = widget.model;
        var cell = model.createCodeCell();
        model.cells.insert(widget.activeCellIndex + 1, cell);
        widget.activeCellIndex++;
        widget.mode = 'edit';
        Private.deselectCells(widget);
    }
    NotebookActions.runAndInsert = runAndInsert;
    /**
     * Run all of the cells in the notebook.
     */
    function runAll(widget, kernel) {
        for (var i = 0; i < widget.childCount(); i++) {
            Private.runCell(widget.childAt(i), kernel);
        }
        widget.mode = 'command';
        widget.activeCellIndex = widget.childCount() - 1;
    }
    NotebookActions.runAll = runAll;
    /**
     * Select the cell below the active cell.
     */
    function selectBelow(widget) {
        if (widget.activeCellIndex === widget.childCount() - 1) {
            return;
        }
        widget.activeCellIndex += 1;
        widget.mode = 'command';
        Private.deselectCells(widget);
    }
    NotebookActions.selectBelow = selectBelow;
    /**
     * Select the above the active cell.
     */
    function selectAbove(widget) {
        if (widget.activeCellIndex === 0) {
            return;
        }
        widget.activeCellIndex -= 1;
        widget.mode = 'command';
        Private.deselectCells(widget);
    }
    NotebookActions.selectAbove = selectAbove;
    /**
     * Extend the selection to the cell above.
     */
    function extendSelectionAbove(widget) {
        // Do not wrap around.
        if (widget.activeCellIndex === 0) {
            return;
        }
        widget.mode = 'command';
        var current = widget.childAt(widget.activeCellIndex);
        var prev = widget.childAt(widget.activeCellIndex - 1);
        if (widget.isSelected(prev)) {
            widget.deselect(current);
            if (widget.activeCellIndex >= 1) {
                var prevPrev = widget.childAt(widget.activeCellIndex - 1);
                if (!widget.isSelected(prevPrev)) {
                    widget.deselect(prev);
                }
            }
            else {
                widget.deselect(prev);
            }
        }
        else {
            widget.select(current);
        }
        widget.activeCellIndex -= 1;
    }
    NotebookActions.extendSelectionAbove = extendSelectionAbove;
    /**
     * Extend the selection to the cell below.
     */
    function extendSelectionBelow(widget) {
        // Do not wrap around.
        if (widget.activeCellIndex === widget.childCount() - 1) {
            return;
        }
        widget.mode = 'command';
        var current = widget.childAt(widget.activeCellIndex);
        var next = widget.childAt(widget.activeCellIndex + 1);
        if (widget.isSelected(next)) {
            widget.deselect(current);
            if (widget.activeCellIndex < widget.childCount() - 1) {
                var nextNext = widget.childAt(widget.activeCellIndex + 1);
                if (!widget.isSelected(nextNext)) {
                    widget.deselect(next);
                }
            }
            else {
                widget.deselect(next);
            }
        }
        else {
            widget.select(current);
        }
        widget.activeCellIndex += 1;
    }
    NotebookActions.extendSelectionBelow = extendSelectionBelow;
    /**
     * Copy the selected cells to a clipboard.
     */
    function copy(widget, clipboard) {
        clipboard.clear();
        var data = [];
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            if (widget.isSelected(child)) {
                data.push(child.model.toJSON());
            }
        }
        clipboard.setData(JUPYTER_CELL_MIME, data);
        Private.deselectCells(widget);
    }
    NotebookActions.copy = copy;
    /**
     * Cut the selected cells to a clipboard.
     */
    function cut(widget, clipboard) {
        clipboard.clear();
        var data = [];
        var model = widget.model;
        var cells = model.cells;
        // Preserve the history as one undo event.
        model.cells.beginCompoundOperation();
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            if (widget.isSelected(child)) {
                data.push(child.model.toJSON());
                cells.remove(child.model);
            }
        }
        if (!model.cells.length) {
            var cell = model.createCodeCell();
            model.cells.add(cell);
        }
        model.cells.endCompoundOperation();
        clipboard.setData(JUPYTER_CELL_MIME, data);
        Private.deselectCells(widget);
    }
    NotebookActions.cut = cut;
    /**
     * Paste cells from a clipboard.
     */
    function paste(widget, clipboard) {
        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {
            return;
        }
        var values = clipboard.getData(JUPYTER_CELL_MIME);
        var model = widget.model;
        var cells = [];
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            switch (value.cell_type) {
                case 'code':
                    cells.push(model.createCodeCell(value));
                    break;
                case 'markdown':
                    cells.push(model.createMarkdownCell(value));
                    break;
                default:
                    cells.push(model.createRawCell(value));
                    break;
            }
        }
        var index = widget.activeCellIndex;
        widget.model.cells.replace(index, 0, cells);
        Private.deselectCells(widget);
    }
    NotebookActions.paste = paste;
    /**
     * Undo a cell action.
     */
    function undo(widget) {
        widget.mode = 'command';
        widget.model.cells.undo();
    }
    NotebookActions.undo = undo;
    /**
     * Redo a cell action.
     */
    function redo(widget) {
        widget.mode = 'command';
        widget.model.cells.redo();
    }
    NotebookActions.redo = redo;
    /**
     * Toggle line numbers on the selected cell(s).
     */
    function toggleLineNumbers(widget) {
        var cell = widget.childAt(widget.activeCellIndex);
        var editor = cell.editor.editor;
        var lineNumbers = editor.getOption('lineNumbers');
        for (var i = 0; i < widget.childCount(); i++) {
            cell = widget.childAt(i);
            if (widget.isSelected(cell)) {
                editor = cell.editor.editor;
                editor.setOption('lineNumbers', !lineNumbers);
            }
        }
    }
    NotebookActions.toggleLineNumbers = toggleLineNumbers;
    /**
     * Toggle the line number of all cells.
     */
    function toggleAllLineNumbers(widget) {
        var cell = widget.childAt(widget.activeCellIndex);
        var editor = cell.editor.editor;
        var lineNumbers = editor.getOption('lineNumbers');
        for (var i = 0; i < widget.childCount(); i++) {
            cell = widget.childAt(i);
            editor = cell.editor.editor;
            editor.setOption('lineNumbers', !lineNumbers);
        }
    }
    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;
    /**
     * Clear the outputs of the currently selected cells.
     */
    function clearOutputs(widget) {
        var cells = widget.model.cells;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells.get(i);
            var child = widget.childAt(i);
            if (widget.isSelected(child) && cell.type === 'code') {
                cell.outputs.clear();
                cell.executionCount = null;
            }
        }
    }
    NotebookActions.clearOutputs = clearOutputs;
    /**
     * Clear the code outputs on the widget.
     */
    function clearAllOutputs(widget) {
        var cells = widget.model.cells;
        for (var i = 0; i < cells.length; i++) {
            var cell = cells.get(i);
            if (cell.type === 'code') {
                cell.outputs.clear();
                cell.executionCount = null;
            }
        }
    }
    NotebookActions.clearAllOutputs = clearAllOutputs;
})(NotebookActions = exports.NotebookActions || (exports.NotebookActions = {}));
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * Deselect all of the cells.
     */
    function deselectCells(widget) {
        for (var i = 0; i < widget.childCount(); i++) {
            var child = widget.childAt(i);
            widget.deselect(child);
        }
    }
    Private.deselectCells = deselectCells;
    /**
     * Clone a cell model.
     */
    function cloneCell(model, cell) {
        switch (cell.type) {
            case 'code':
                return model.createCodeCell(cell.toJSON());
            case 'markdown':
                return model.createMarkdownCell(cell.toJSON());
            default:
                return model.createRawCell(cell.toJSON());
        }
    }
    Private.cloneCell = cloneCell;
    /**
     * Run a cell.
     */
    function runCell(widget, kernel) {
        switch (widget.model.type) {
            case 'markdown':
                widget.rendered = true;
                break;
            case 'code':
                if (kernel) {
                    widget.execute(kernel);
                }
                else {
                    widget.model.executionCount = null;
                }
                break;
            default:
                break;
        }
    }
    Private.runCell = runCell;
})(Private || (Private = {}));
