// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_observablelist_1 = require('phosphor-observablelist');
var phosphor_panel_1 = require('phosphor-panel');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
var cells_1 = require('../cells');
var mimetype_1 = require('../common/mimetype');
/**
 * The class name added to notebook widgets.
 */
var NB_CLASS = 'jp-Notebook';
/**
 * The class name added to notebook widget cells.
 */
var NB_CELL_CLASS = 'jp-Notebook-cell';
/**
 * The class name added to a notebook in edit mode.
 */
var EDIT_CLASS = 'jp-mod-editMode';
/**
 * The class name added to a notebook in command mode.
 */
var COMMAND_CLASS = 'jp-mod-commandMode';
/**
 * The class name added to the active cell.
 */
var ACTIVE_CLASS = 'jp-mod-active';
/**
 * The class name added to selected cells.
 */
var SELECTED_CLASS = 'jp-mod-selected';
/**
 * The class name added to an active cell when there are other selected cells.
 */
var OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';
/**
 * A widget which renders notebooks.
 */
var NotebookRenderer = (function (_super) {
    __extends(NotebookRenderer, _super);
    /**
     * Construct a notebook widget.
     */
    function NotebookRenderer(model, rendermime) {
        _super.call(this);
        this._model = null;
        this._rendermime = null;
        this._mimetype = 'text/plain';
        this._langInfoCursor = null;
        this.node.tabIndex = -1; // Allow the widget to take focus.
        this.addClass(NB_CLASS);
        this._model = model;
        this._rendermime = rendermime;
        this._langInfoCursor = model.getMetadata('language_info');
        this._mimetype = this.getMimetype();
        this.layout = new phosphor_panel_1.PanelLayout();
        // Add the current cells.
        if (model.cells.length === 0) {
            // Add a new code cell if there are no cells.
            var cell = model.createCodeCell();
            model.cells.add(cell);
        }
        var layout = this.layout;
        var constructor = this.constructor;
        var factory = constructor.createCell;
        for (var i = 0; i < model.cells.length; i++) {
            var widget = factory(model.cells.get(i), rendermime);
            this.initializeCellWidget(widget);
            layout.addChild(widget);
        }
        model.cells.changed.connect(this.onCellsChanged, this);
        model.metadataChanged.connect(this.onMetadataChanged, this);
    }
    /**
     * Create a new cell widget given a cell model.
     */
    NotebookRenderer.createCell = function (cell, rendermime) {
        switch (cell.type) {
            case 'code':
                return new cells_1.CodeCellWidget(cell, rendermime);
            case 'markdown':
                return new cells_1.MarkdownCellWidget(cell, rendermime);
            // If there are any issues, just return a raw
            // widget so the lists stay in sync.
            default:
                return new cells_1.RawCellWidget(cell);
        }
    };
    Object.defineProperty(NotebookRenderer.prototype, "model", {
        /**
         * Get the model for the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotebookRenderer.prototype, "rendermime", {
        /**
         * Get the rendermime instance used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._rendermime;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the child widget at the specified index.
     */
    NotebookRenderer.prototype.childAt = function (index) {
        var layout = this.layout;
        return layout.childAt(index);
    };
    /**
     * Get the number of child widgets.
     */
    NotebookRenderer.prototype.childCount = function () {
        var layout = this.layout;
        return layout.childCount();
    };
    /**
     * Dispose of the resources held by the widget.
     */
    NotebookRenderer.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._langInfoCursor = null;
        this._model.dispose();
        this._model = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Find the cell index containing the target html element.
     *
     * #### Notes
     * Returns -1 if the cell is not found.
     */
    NotebookRenderer.prototype.findCell = function (node) {
        // Trace up the DOM hierarchy to find the root cell node.
        // Then find the corresponding child and select it.
        var layout = this.layout;
        while (node && node !== this.node) {
            if (node.classList.contains(NB_CELL_CLASS)) {
                for (var i = 0; i < layout.childCount(); i++) {
                    if (layout.childAt(i).node === node) {
                        return i;
                    }
                }
                break;
            }
            node = node.parentElement;
        }
        return -1;
    };
    /**
     * Handle changes to the notebook model.
     */
    NotebookRenderer.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'language_info':
                this._mimetype = this.getMimetype();
                this._updateMimetypes();
                break;
            default:
                break;
        }
    };
    /**
     * Handle a change cells event.
     */
    NotebookRenderer.prototype.onCellsChanged = function (sender, args) {
        var layout = this.layout;
        var constructor = this.constructor;
        var factory = constructor.createCell;
        var widget;
        switch (args.type) {
            case phosphor_observablelist_1.ListChangeType.Add:
                widget = factory(args.newValue, this._rendermime);
                this.initializeCellWidget(widget);
                layout.insertChild(args.newIndex, widget);
                break;
            case phosphor_observablelist_1.ListChangeType.Move:
                layout.insertChild(args.newIndex, layout.childAt(args.oldIndex));
                break;
            case phosphor_observablelist_1.ListChangeType.Remove:
                widget = layout.childAt(args.oldIndex);
                layout.removeChild(widget);
                widget.dispose();
                break;
            case phosphor_observablelist_1.ListChangeType.Replace:
                var oldValues = args.oldValue;
                for (var i = 0; i < oldValues.length; i++) {
                    widget = layout.childAt(args.oldIndex);
                    layout.removeChild(widget);
                    widget.dispose();
                }
                var newValues = args.newValue;
                for (var i = newValues.length; i > 0; i--) {
                    widget = factory(newValues[i - 1], this._rendermime);
                    this.initializeCellWidget(widget);
                    layout.insertChild(args.newIndex, widget);
                }
                break;
            case phosphor_observablelist_1.ListChangeType.Set:
                widget = layout.childAt(args.newIndex);
                layout.removeChild(widget);
                widget.dispose();
                widget = factory(args.newValue, this._rendermime);
                layout.insertChild(args.newIndex, widget);
                this.initializeCellWidget(widget);
                break;
            default:
                return;
        }
        this.update();
    };
    /**
     * The mime type for code cells.
     *
     * #### Notes
     * The default implementation uses the language info to set the
     * mimetype.
     */
    NotebookRenderer.prototype.getMimetype = function () {
        var info = this._langInfoCursor.getValue();
        return mimetype_1.mimetypeForLanguage(info);
    };
    /**
     * Initialize a cell widget.
     */
    NotebookRenderer.prototype.initializeCellWidget = function (widget) {
        widget.addClass(NB_CELL_CLASS);
        if (widget.model.type === 'code') {
            widget.mimetype = this._mimetype;
        }
    };
    /**
     * Update the mimetype of code widgets.
     */
    NotebookRenderer.prototype._updateMimetypes = function () {
        var layout = this.layout;
        for (var i = 0; i < layout.childCount(); i++) {
            var widget = layout.childAt(i);
            if (widget instanceof cells_1.CodeCellWidget) {
                widget.mimetype = this._mimetype;
            }
        }
    };
    return NotebookRenderer;
}(phosphor_widget_1.Widget));
exports.NotebookRenderer = NotebookRenderer;
/**
 * A notebook widget that supports interactivity.
 */
var ActiveNotebook = (function (_super) {
    __extends(ActiveNotebook, _super);
    function ActiveNotebook() {
        _super.apply(this, arguments);
        this._mode = 'command';
        this._activeCellIndex = 0;
    }
    Object.defineProperty(ActiveNotebook.prototype, "stateChanged", {
        /**
         * A signal emitted when the state of the notebook changes.
         */
        get: function () {
            return Private.stateChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActiveNotebook.prototype, "mode", {
        /**
         * The interactivity mode of the notebook.
         */
        get: function () {
            return this._mode;
        },
        set: function (newValue) {
            if (newValue === this._mode) {
                return;
            }
            var oldValue = this._mode;
            this._mode = newValue;
            // Edit mode deselects all cells.
            if (newValue === 'edit') {
                var layout = this.layout;
                for (var i = 0; i < layout.childCount(); i++) {
                    var widget = layout.childAt(i);
                    this.deselect(widget);
                }
            }
            this.stateChanged.emit({ name: 'mode', oldValue: oldValue, newValue: newValue });
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActiveNotebook.prototype, "activeCellIndex", {
        /**
         * The active cell index of the notebook.
         */
        get: function () {
            return this._activeCellIndex;
        },
        set: function (newValue) {
            newValue = Math.max(newValue, 0);
            newValue = Math.min(newValue, this.model.cells.length - 1);
            if (newValue === this._activeCellIndex) {
                return;
            }
            var oldValue = this._activeCellIndex;
            this._activeCellIndex = newValue;
            var widget = this.layout.childAt(newValue);
            if (widget instanceof cells_1.MarkdownCellWidget) {
                if (this.mode === 'edit') {
                    widget.rendered = false;
                }
            }
            this.stateChanged.emit({ name: 'activeCellIndex', oldValue: oldValue, newValue: newValue });
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Select a cell widget.
     */
    ActiveNotebook.prototype.select = function (widget) {
        Private.selectedProperty.set(widget, true);
        this.update();
    };
    /**
     * Deselect a cell widget.
     *
     * #### Notes
     * This has no effect on the "active" cell.
     */
    ActiveNotebook.prototype.deselect = function (widget) {
        Private.selectedProperty.set(widget, false);
        this.update();
    };
    /**
     * Whether a cell is selected or is the active cell.
     */
    ActiveNotebook.prototype.isSelected = function (widget) {
        var layout = this.layout;
        if (layout.childAt(this._activeCellIndex) === widget) {
            return true;
        }
        return Private.selectedProperty.get(widget);
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    ActiveNotebook.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'dblclick':
                this._evtDblClick(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after_attach` messages for the widget.
     */
    ActiveNotebook.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('dblclick', this);
        this.update();
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    ActiveNotebook.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('dblclick', this);
    };
    /**
     * Handle `update-request` messages sent to the widget.
     */
    ActiveNotebook.prototype.onUpdateRequest = function (msg) {
        // Set the appropriate classes on the cells.
        var layout = this.layout;
        var widget = layout.childAt(this.activeCellIndex);
        if (this.mode === 'edit') {
            this.addClass(EDIT_CLASS);
            this.removeClass(COMMAND_CLASS);
            if (widget) {
                widget.focus();
            }
            if (widget instanceof cells_1.MarkdownCellWidget) {
                widget.rendered = false;
            }
        }
        else {
            this.addClass(COMMAND_CLASS);
            this.removeClass(EDIT_CLASS);
            this.node.focus();
        }
        if (widget) {
            widget.addClass(ACTIVE_CLASS);
            Private.scrollIfNeeded(this.parent.node, widget.node);
        }
        var count = 0;
        for (var i = 0; i < layout.childCount(); i++) {
            widget = layout.childAt(i);
            if (i !== this.activeCellIndex) {
                widget.removeClass(ACTIVE_CLASS);
            }
            widget.removeClass(OTHER_SELECTED_CLASS);
            if (this.isSelected(widget)) {
                widget.addClass(SELECTED_CLASS);
                count++;
            }
            else {
                widget.removeClass(SELECTED_CLASS);
            }
        }
        if (count > 1) {
            widget = layout.childAt(this.activeCellIndex);
            widget.addClass(OTHER_SELECTED_CLASS);
        }
    };
    /**
     * Initialize a cell widget.
     */
    ActiveNotebook.prototype.initializeCellWidget = function (widget) {
        _super.prototype.initializeCellWidget.call(this, widget);
        widget.editor.edgeRequested.connect(this.onEdgeRequest, this);
    };
    /**
     * Handle edge request signals from cells.
     */
    ActiveNotebook.prototype.onEdgeRequest = function (widget, location) {
        if (location === 'top') {
            this.activeCellIndex--;
        }
        else {
            this.activeCellIndex++;
        }
    };
    /**
     * Handle `click` events for the widget.
     */
    ActiveNotebook.prototype._evtClick = function (event) {
        var model = this.model;
        if (model.readOnly) {
            return;
        }
        var i = this.findCell(event.target);
        if (i === -1) {
            return;
        }
        this.activeCellIndex = i;
        this.mode = document.activeElement === this.node ? 'command' : 'edit';
    };
    /**
     * Handle `dblclick` events for the widget.
     */
    ActiveNotebook.prototype._evtDblClick = function (event) {
        var model = this.model;
        if (model.readOnly) {
            return;
        }
        var i = this.findCell(event.target);
        if (i === -1) {
            return;
        }
        var cell = model.cells.get(i);
        var widget = this.layout.childAt(i);
        if (cell.type !== 'markdown' || !widget.rendered) {
            return;
        }
        if (widget.node.contains(event.target)) {
            this.mode = 'edit';
        }
    };
    return ActiveNotebook;
}(NotebookRenderer));
exports.ActiveNotebook = ActiveNotebook;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * An attached property for the selected state of a cell.
     */
    Private.selectedProperty = new phosphor_properties_1.Property({
        name: 'selected',
        value: false
    });
    /**
     * A signal emitted when the state changes on the notebook.
     */
    Private.stateChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * Scroll an element into view if needed.
     *
     * @param area - The scroll area element.
     *
     * @param elem - The element of interest.
     */
    function scrollIfNeeded(area, elem) {
        var ar = area.getBoundingClientRect();
        var er = elem.getBoundingClientRect();
        if (er.top < ar.top - 10) {
            area.scrollTop -= ar.top - er.top + 10;
        }
        else if (er.bottom > ar.bottom + 10) {
            area.scrollTop += er.bottom - ar.bottom + 10;
        }
    }
    Private.scrollIfNeeded = scrollIfNeeded;
})(Private || (Private = {}));
