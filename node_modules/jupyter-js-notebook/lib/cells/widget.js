// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var codemirror_1 = require('jupyter-js-ui/lib/codemirror');
var phosphor_panel_1 = require('phosphor-panel');
var phosphor_widget_1 = require('phosphor-widget');
var output_area_1 = require('../output-area');
var sanitizer_1 = require('sanitizer');
var editor_1 = require('./editor');
/**
 * The class name added to cell widgets.
 */
var CELL_CLASS = 'jp-Cell';
/**
 * The class name added to input area widgets.
 */
var INPUT_CLASS = 'jp-InputArea';
/**
 * The class name added to the prompt area of cell.
 */
var PROMPT_CLASS = 'jp-InputArea-prompt';
/**
 * The class name added to the editor area of the cell.
 */
var EDITOR_CLASS = 'jp-InputArea-editor';
/**
 * The class name added to the cell when collapsed.
 */
var COLLAPSED_CLASS = 'jp-mod-collapsed';
/**
 * The class name added to the cell when readonly.
 */
var READONLY_CLASS = 'jp-mod-readOnly';
/**
 * The class name added to code cells.
 */
var CODE_CELL_CLASS = 'jp-CodeCell';
/**
 * The class name added to markdown cells.
 */
var MARKDOWN_CELL_CLASS = 'jp-MarkdownCell';
/**
 * The class name added to the markdown cell renderer widget.
 */
var RENDERER_CLASS = 'jp-MarkdownCell-renderer';
/**
 * The class name added to raw cells.
 */
var RAW_CELL_CLASS = 'jp-RawCell';
/**
 * The class name added to a rendered markdown cell.
 */
var RENDERED_CLASS = 'jp-mod-rendered';
/**
 * The text applied to an empty markdown cell.
 */
var DEFAULT_MARKDOWN_TEXT = 'Type Markdown and LaTeX: $ Î±^2 $';
/**
 * A base cell widget.
 */
var BaseCellWidget = (function (_super) {
    __extends(BaseCellWidget, _super);
    /**
     * Construct a new base cell widget.
     */
    function BaseCellWidget(model) {
        _super.call(this);
        this._input = null;
        this._editor = null;
        this._model = null;
        this._mimetype = 'text/plain';
        this._readOnly = false;
        this._trustedCursor = null;
        this._trusted = false;
        this.addClass(CELL_CLASS);
        this._model = model;
        var ctor = this.constructor;
        this._editor = ctor.createCellEditor(model);
        this._input = ctor.createInputArea(this._editor);
        // Set the editor mode to be the default MIME type.
        codemirror_1.loadModeByMIME(this._editor.editor, this._mimetype);
        this.layout = new phosphor_panel_1.PanelLayout();
        this.layout.addChild(this._input);
        model.metadataChanged.connect(this.onMetadataChanged, this);
        this._trustedCursor = model.getMetadata('trusted');
        this._trusted = this._trustedCursor.getValue();
    }
    /**
     * Create a new cell editor for the widget.
     */
    BaseCellWidget.createCellEditor = function (model) {
        return new editor_1.CellEditorWidget(model);
    };
    /**
     * Create a new input area for the widget.
     */
    BaseCellWidget.createInputArea = function (editor) {
        return new InputAreaWidget(editor);
    };
    Object.defineProperty(BaseCellWidget.prototype, "model", {
        /**
         * Get the model used by the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "editor", {
        /**
         * Get the editor widget used by the cell.
         *
         * #### Notes
         * This is a ready-only property.
         */
        get: function () {
            return this._editor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "mimetype", {
        /**
         * The mimetype used by the cell.
         */
        get: function () {
            return this._mimetype;
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (this._mimetype === value) {
                return;
            }
            this._mimetype = value;
            codemirror_1.loadModeByMIME(this.editor.editor, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "readOnly", {
        /**
         * The read only state of the cell.
         */
        get: function () {
            return this._readOnly;
        },
        set: function (value) {
            if (value === this._readOnly) {
                return;
            }
            this._readOnly = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseCellWidget.prototype, "trusted", {
        /**
         * The trusted state of the cell.
         */
        get: function () {
            return this._trusted;
        },
        set: function (value) {
            this._trustedCursor.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Focus the widget.
     */
    BaseCellWidget.prototype.focus = function () {
        this.editor.editor.focus();
    };
    /**
     * Set the prompt for the widget.
     */
    BaseCellWidget.prototype.setPrompt = function (value) {
        this._input.setPrompt(value);
    };
    /**
     * Toggle whether the input area is shown.
     */
    BaseCellWidget.prototype.toggleInput = function (value) {
        if (value) {
            this._input.show();
            this.focus();
        }
        else {
            this._input.hide();
        }
    };
    /**
     * Dispose of the resources held by the widget.
     */
    BaseCellWidget.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._model = null;
        this._input = null;
        this._editor = null;
        this._trustedCursor = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `after-attach` messages.
     */
    BaseCellWidget.prototype.onAfterAttach = function (msg) {
        this.update();
    };
    /**
     * Handle `update_request` messages.
     */
    BaseCellWidget.prototype.onUpdateRequest = function (message) {
        // Handle read only state.
        var option = this._readOnly ? 'nocursor' : false;
        this.editor.editor.setOption('readOnly', option);
        this.toggleClass(READONLY_CLASS, this._readOnly);
    };
    /**
     * Handle changes in the model.
     */
    BaseCellWidget.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'trusted':
                this._trusted = this._trustedCursor.getValue();
                this.update();
                break;
            default:
                break;
        }
    };
    return BaseCellWidget;
}(phosphor_widget_1.Widget));
exports.BaseCellWidget = BaseCellWidget;
/**
 * A widget for a code cell.
 */
var CodeCellWidget = (function (_super) {
    __extends(CodeCellWidget, _super);
    /**
     * Construct a code cell widget.
     */
    function CodeCellWidget(model, rendermime) {
        _super.call(this, model);
        this._output = null;
        this._rendermime = null;
        this._collapsedCursor = null;
        this._scrolledCursor = null;
        this._rendermime = rendermime;
        this.addClass(CODE_CELL_CLASS);
        var constructor = this.constructor;
        this._output = constructor.createOutput(model.outputs, rendermime);
        this._output.trusted = this.trusted;
        this.layout.addChild(this._output);
        this._collapsedCursor = model.getMetadata('collapsed');
        this._scrolledCursor = model.getMetadata('scrolled');
        this.setPrompt(String(model.executionCount));
        model.stateChanged.connect(this.onModelChanged, this);
    }
    /**
     * Create an output area widget.
     */
    CodeCellWidget.createOutput = function (outputs, rendermime) {
        return new output_area_1.OutputAreaWidget(outputs, rendermime);
    };
    /**
     * Dispose of the resources used by the widget.
     */
    CodeCellWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._rendermime = null;
        this._collapsedCursor = null;
        this._scrolledCursor = null;
        this._output = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Execute the cell given a kernel.
     */
    CodeCellWidget.prototype.execute = function (kernel) {
        var model = this.model;
        var code = model.source;
        if (!code.trim()) {
            model.executionCount = null;
            return Promise.resolve(void 0);
        }
        model.executionCount = null;
        this.setPrompt('*');
        this.trusted = true;
        var outputs = model.outputs;
        return output_area_1.executeCode(code, kernel, outputs).then(function (reply) {
            model.executionCount = reply.execution_count;
        });
    };
    /**
     * Handle `update_request` messages.
     */
    CodeCellWidget.prototype.onUpdateRequest = function (message) {
        this.toggleClass(COLLAPSED_CLASS, this._collapsedCursor.getValue());
        // TODO: handle scrolled state.
        this._output.trusted = this.trusted;
        _super.prototype.onUpdateRequest.call(this, message);
    };
    /**
     * Handle changes in the model.
     */
    CodeCellWidget.prototype.onModelChanged = function (model, args) {
        switch (args.name) {
            case 'executionCount':
                this.setPrompt(String(model.executionCount));
                break;
            default:
                break;
        }
    };
    /**
     * Handle changes in the metadata.
     */
    CodeCellWidget.prototype.onMetadataChanged = function (model, args) {
        switch (args.name) {
            case 'collapsed':
            case 'scrolled':
                this.update();
                break;
            default:
                break;
        }
        _super.prototype.onMetadataChanged.call(this, model, args);
    };
    return CodeCellWidget;
}(BaseCellWidget));
exports.CodeCellWidget = CodeCellWidget;
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
var MarkdownCellWidget = (function (_super) {
    __extends(MarkdownCellWidget, _super);
    /**
     * Construct a Markdown cell widget.
     */
    function MarkdownCellWidget(model, rendermime) {
        _super.call(this, model);
        this._rendermime = null;
        this._renderer = null;
        this._rendered = true;
        this._prev = '';
        this._rendermime = rendermime;
        this.addClass(MARKDOWN_CELL_CLASS);
        // Insist on the Github-flavored markdown mode.
        this.mimetype = 'text/x-ipythongfm';
        this._renderer = new phosphor_widget_1.Widget();
        this._renderer.addClass(RENDERER_CLASS);
        this.layout.addChild(this._renderer);
    }
    Object.defineProperty(MarkdownCellWidget.prototype, "rendered", {
        /**
         * Whether the cell is rendered.
         */
        get: function () {
            return this._rendered;
        },
        set: function (value) {
            if (value === this._rendered) {
                return;
            }
            this._rendered = value;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resource held by the widget.
     */
    MarkdownCellWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._renderer = null;
        this._rendermime = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle `update_request` messages.
     */
    MarkdownCellWidget.prototype.onUpdateRequest = function (message) {
        var model = this.model;
        if (this.rendered) {
            var text = model.source || DEFAULT_MARKDOWN_TEXT;
            // Do not re-render if the text has not changed.
            if (text !== this._prev) {
                text = sanitizer_1.sanitize(text);
                var bundle = { 'text/markdown': text };
                this._renderer.dispose();
                this._renderer = this._rendermime.render(bundle) || new phosphor_widget_1.Widget();
                this._renderer.addClass(RENDERER_CLASS);
                this.layout.addChild(this._renderer);
            }
            this._prev = text;
            this._renderer.show();
            this.toggleInput(false);
            this.addClass(RENDERED_CLASS);
        }
        else {
            this._renderer.hide();
            this.toggleInput(true);
            this.removeClass(RENDERED_CLASS);
        }
        _super.prototype.onUpdateRequest.call(this, message);
    };
    return MarkdownCellWidget;
}(BaseCellWidget));
exports.MarkdownCellWidget = MarkdownCellWidget;
/**
 * A widget for a raw cell.
 */
var RawCellWidget = (function (_super) {
    __extends(RawCellWidget, _super);
    /**
     * Construct a raw cell widget.
     */
    function RawCellWidget(model) {
        _super.call(this, model);
        this.addClass(RAW_CELL_CLASS);
    }
    return RawCellWidget;
}(BaseCellWidget));
exports.RawCellWidget = RawCellWidget;
/**
 * An input area widget, which hosts a prompt and an editor widget.
 */
var InputAreaWidget = (function (_super) {
    __extends(InputAreaWidget, _super);
    /**
     * Construct an input area widget.
     */
    function InputAreaWidget(editor) {
        _super.call(this);
        this.addClass(INPUT_CLASS);
        editor.addClass(EDITOR_CLASS);
        this.layout = new phosphor_panel_1.PanelLayout();
        var prompt = new phosphor_widget_1.Widget();
        prompt.addClass(PROMPT_CLASS);
        var layout = this.layout;
        layout.addChild(prompt);
        layout.addChild(editor);
    }
    /**
     * Set the prompt of the input area.
     */
    InputAreaWidget.prototype.setPrompt = function (value) {
        var prompt = this.layout.childAt(0);
        if (value === 'null') {
            value = ' ';
        }
        var text = "In [" + (value || ' ') + "]:";
        prompt.node.textContent = text;
    };
    return InputAreaWidget;
}(phosphor_widget_1.Widget));
exports.InputAreaWidget = InputAreaWidget;
