import { IKernel } from 'jupyter-js-services';
import { RenderMime } from 'jupyter-js-ui/lib/rendermime';
import { Message } from 'phosphor-messaging';
import { IChangedArgs } from 'phosphor-properties';
import { Widget } from 'phosphor-widget';
import { OutputAreaWidget, ObservableOutputs } from '../output-area';
import { CellEditorWidget } from './editor';
import { ICodeCellModel, ICellModel } from './model';
/**
 * A base cell widget.
 */
export declare class BaseCellWidget extends Widget {
    /**
     * Create a new cell editor for the widget.
     */
    static createCellEditor(model: ICellModel): CellEditorWidget;
    /**
     * Create a new input area for the widget.
     */
    static createInputArea(editor: CellEditorWidget): InputAreaWidget;
    /**
     * Construct a new base cell widget.
     */
    constructor(model: ICellModel);
    /**
     * Get the model used by the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    model: ICellModel;
    /**
     * Get the editor widget used by the cell.
     *
     * #### Notes
     * This is a ready-only property.
     */
    editor: CellEditorWidget;
    /**
     * The mimetype used by the cell.
     */
    mimetype: string;
    /**
     * The read only state of the cell.
     */
    readOnly: boolean;
    /**
     * The trusted state of the cell.
     */
    trusted: boolean;
    /**
     * Focus the widget.
     */
    focus(): void;
    /**
     * Set the prompt for the widget.
     */
    setPrompt(value: string): void;
    /**
     * Toggle whether the input area is shown.
     */
    toggleInput(value: boolean): void;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Handle `after-attach` messages.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `update_request` messages.
     */
    protected onUpdateRequest(message: Message): void;
    /**
     * Handle changes in the model.
     */
    protected onMetadataChanged(model: ICellModel, args: IChangedArgs<any>): void;
    private _input;
    private _editor;
    private _model;
    private _mimetype;
    private _readOnly;
    private _trustedCursor;
    private _trusted;
}
/**
 * A widget for a code cell.
 */
export declare class CodeCellWidget extends BaseCellWidget {
    /**
     * Create an output area widget.
     */
    static createOutput(outputs: ObservableOutputs, rendermime: RenderMime<Widget>): OutputAreaWidget;
    /**
     * Construct a code cell widget.
     */
    constructor(model: ICodeCellModel, rendermime: RenderMime<Widget>);
    /**
     * Dispose of the resources used by the widget.
     */
    dispose(): void;
    /**
     * Execute the cell given a kernel.
     */
    execute(kernel: IKernel): Promise<void>;
    /**
     * Handle `update_request` messages.
     */
    protected onUpdateRequest(message: Message): void;
    /**
     * Handle changes in the model.
     */
    protected onModelChanged(model: ICodeCellModel, args: IChangedArgs<any>): void;
    /**
     * Handle changes in the metadata.
     */
    protected onMetadataChanged(model: ICodeCellModel, args: IChangedArgs<any>): void;
    private _output;
    private _rendermime;
    private _collapsedCursor;
    private _scrolledCursor;
}
/**
 * A widget for a Markdown cell.
 *
 * #### Notes
 * Things get complicated if we want the rendered text to update
 * any time the text changes, the text editor model changes,
 * or the input area model changes.  We don't support automatically
 * updating the rendered text in all of these cases.
 */
export declare class MarkdownCellWidget extends BaseCellWidget {
    /**
     * Construct a Markdown cell widget.
     */
    constructor(model: ICellModel, rendermime: RenderMime<Widget>);
    /**
     * Whether the cell is rendered.
     */
    rendered: boolean;
    /**
     * Dispose of the resource held by the widget.
     */
    dispose(): void;
    /**
     * Handle `update_request` messages.
     */
    protected onUpdateRequest(message: Message): void;
    private _rendermime;
    private _renderer;
    private _rendered;
    private _prev;
}
/**
 * A widget for a raw cell.
 */
export declare class RawCellWidget extends BaseCellWidget {
    /**
     * Construct a raw cell widget.
     */
    constructor(model: ICellModel);
}
/**
 * An input area widget, which hosts a prompt and an editor widget.
 */
export declare class InputAreaWidget extends Widget {
    /**
     * Construct an input area widget.
     */
    constructor(editor: CellEditorWidget);
    /**
     * Set the prompt of the input area.
     */
    setPrompt(value: string): void;
}
