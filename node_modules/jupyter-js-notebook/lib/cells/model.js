// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utils = require('jupyter-js-utils');
var phosphor_signaling_1 = require('phosphor-signaling');
var json_1 = require('../common/json');
var metadata_1 = require('../common/metadata');
var output_area_1 = require('../output-area');
/**
 * An implementation of the cell model.
 */
var CellModel = (function () {
    /**
     * Construct a cell model from optional cell content.
     */
    function CellModel(cell) {
        this._metadata = Object.create(null);
        this._cursors = Object.create(null);
        this._source = '';
        if (!cell) {
            return;
        }
        this.source = cell.source;
        var metadata = utils.copy(cell.metadata);
        if (this.type !== 'raw') {
            delete metadata['format'];
        }
        if (this.type !== 'code') {
            delete metadata['collapsed'];
            delete metadata['scrolled'];
        }
        this._metadata = metadata;
    }
    Object.defineProperty(CellModel.prototype, "contentChanged", {
        /**
         * A signal emitted when the state of the model changes.
         */
        get: function () {
            return Private.contentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellModel.prototype, "stateChanged", {
        /**
         * A signal emitted when a model state changes.
         */
        get: function () {
            return Private.stateChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellModel.prototype, "metadataChanged", {
        /**
         * A signal emitted when a metadata field changes.
         */
        get: function () {
            return Private.metadataChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellModel.prototype, "source", {
        /**
         * The input content of the cell.
         */
        get: function () {
            return this._source;
        },
        set: function (newValue) {
            if (this._source === newValue) {
                return;
            }
            var oldValue = this._source;
            this._source = newValue;
            this.contentChanged.emit(void 0);
            this.stateChanged.emit({ name: 'source', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CellModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._metadata === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    CellModel.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        phosphor_signaling_1.clearSignalData(this);
        for (var key in this._cursors) {
            this._cursors[key].dispose();
        }
        this._cursors = null;
        this._metadata = null;
    };
    /**
     * Serialize the model to JSON.
     */
    CellModel.prototype.toJSON = function () {
        return {
            cell_type: this.type,
            source: this.source,
            metadata: utils.copy(this._metadata)
        };
    };
    /**
     * Get a metadata cursor for the cell.
     *
     * #### Notes
     * Metadata associated with the nbformat spec are set directly
     * on the model.  This method is used to interact with a namespaced
     * set of metadata on the cell.
     */
    CellModel.prototype.getMetadata = function (name) {
        var _this = this;
        if (name in this._cursors) {
            return this._cursors[name];
        }
        var cursor = new metadata_1.MetadataCursor(name, function () {
            return _this._metadata[name];
        }, function (value) {
            _this.setCursorData(name, value);
        });
        this._cursors[name] = cursor;
        return cursor;
    };
    /**
     * List the metadata namespace keys for the notebook.
     *
     * #### Notes
     * Metadata associated with the nbformat are not included.
     */
    CellModel.prototype.listMetadata = function () {
        return Object.keys(this._metadata);
    };
    /**
     * Set the cursor data for a given field.
     */
    CellModel.prototype.setCursorData = function (name, newValue) {
        var oldValue = this._metadata[name];
        if (json_1.deepEqual(oldValue, newValue)) {
            return;
        }
        this._metadata[name] = newValue;
        this.contentChanged.emit(void 0);
        this.metadataChanged.emit({ name: name, oldValue: oldValue, newValue: newValue });
    };
    return CellModel;
}());
exports.CellModel = CellModel;
/**
 * An implementation of a raw cell model.
 */
var RawCellModel = (function (_super) {
    __extends(RawCellModel, _super);
    function RawCellModel() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(RawCellModel.prototype, "type", {
        /**
         * The type of the cell.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return 'raw';
        },
        enumerable: true,
        configurable: true
    });
    return RawCellModel;
}(CellModel));
exports.RawCellModel = RawCellModel;
/**
 * An implementation of a markdown cell model.
 */
var MarkdownCellModel = (function (_super) {
    __extends(MarkdownCellModel, _super);
    function MarkdownCellModel() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(MarkdownCellModel.prototype, "type", {
        /**
         * The type of the cell.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return 'markdown';
        },
        enumerable: true,
        configurable: true
    });
    return MarkdownCellModel;
}(CellModel));
exports.MarkdownCellModel = MarkdownCellModel;
/**
 * An implementation of a code cell Model.
 */
var CodeCellModel = (function (_super) {
    __extends(CodeCellModel, _super);
    /**
     * Construct a new code cell with optional original cell content.
     */
    function CodeCellModel(cell) {
        var _this = this;
        _super.call(this, cell);
        this._outputs = null;
        this._executionCount = null;
        this._outputs = new output_area_1.ObservableOutputs();
        if (cell && cell.cell_type === 'code') {
            this.executionCount = cell.execution_count;
            this._outputs.assign(cell.outputs);
        }
        this._outputs.changed.connect(function () {
            _this.contentChanged.emit(void 0);
        });
    }
    Object.defineProperty(CodeCellModel.prototype, "type", {
        /**
         * The type of the cell.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return 'code';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeCellModel.prototype, "executionCount", {
        /**
         * The execution count of the cell.
         */
        get: function () {
            return this._executionCount;
        },
        set: function (newValue) {
            if (newValue === this._executionCount) {
                return;
            }
            var oldValue = this.executionCount;
            this._executionCount = newValue;
            this.contentChanged.emit(void 0);
            this.stateChanged.emit({ name: 'executionCount', oldValue: oldValue, newValue: newValue });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodeCellModel.prototype, "outputs", {
        /**
         * The cell outputs.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._outputs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the model.
     */
    CodeCellModel.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._outputs.clear(false);
        this._outputs = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Serialize the model to JSON.
     */
    CodeCellModel.prototype.toJSON = function () {
        var cell = _super.prototype.toJSON.call(this);
        cell.execution_count = this.executionCount;
        var outputs = this.outputs;
        cell.outputs = [];
        for (var i = 0; i < outputs.length; i++) {
            cell.outputs.push(outputs.get(i));
        }
        return cell;
    };
    return CodeCellModel;
}(CellModel));
exports.CodeCellModel = CodeCellModel;
/**
 * A namespace for cell private data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when the state of the model changes.
     */
    Private.contentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a model state changes.
     */
    Private.stateChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a metadata field changes.
     */
    Private.metadataChangedSignal = new phosphor_signaling_1.Signal();
})(Private || (Private = {}));
