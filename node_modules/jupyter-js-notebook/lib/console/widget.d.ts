import { IKernel, INotebookSession } from 'jupyter-js-services';
import { RenderMime } from 'jupyter-js-ui/lib/rendermime';
import { Message } from 'phosphor-messaging';
import { Widget } from 'phosphor-widget';
import { Panel } from 'phosphor-panel';
import { CodeCellWidget, RawCellWidget } from '../cells';
import { EdgeLocation, CellEditorWidget, ITextChange, ICompletionRequest } from '../cells/editor';
import { nbformat } from '../notebook';
import { ConsoleTooltip } from './tooltip';
import { IConsoleHistory } from './history';
import { CompletionWidget } from '../completion';
/**
 * A panel which contains a toolbar and a console.
 */
export declare class ConsolePanel extends Panel {
    /**
     * Create a new console widget for the panel.
     */
    static createConsole(session: INotebookSession, rendermime: RenderMime<Widget>): ConsoleWidget;
    /**
     * Construct a console panel.
     */
    constructor(session: INotebookSession, rendermime: RenderMime<Widget>);
    /**
     * The console widget used by the panel.
     *
     * #### Notes
     * This is a read-only property.
     */
    content: ConsoleWidget;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    handleEvent(event: Event): void;
    /**
     * Handle `after_attach` messages for the widget.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `before_detach` messages for the widget.
     */
    protected onBeforeDetach(msg: Message): void;
    /**
     * Handle `'close-request'` messages.
     */
    protected onCloseRequest(msg: Message): void;
    private _console;
}
/**
 * A widget containing a Jupyter console.
 */
export declare class ConsoleWidget extends Widget {
    /**
     * Create a new banner widget given a banner model.
     */
    static createBanner(): RawCellWidget;
    /**
     * Create a new prompt widget given a prompt model and a rendermime.
     */
    static createPrompt(rendermime: RenderMime<Widget>): CodeCellWidget;
    /**
     * Create a new completion widget.
     */
    static createCompletion(): CompletionWidget;
    /**
     * Create a console history.
     */
    static createHistory(kernel: IKernel): IConsoleHistory;
    /**
     * Create a new tooltip widget.
     *
     * @returns A ConsoleTooltip widget.
     */
    static createTooltip(): ConsoleTooltip;
    /**
     * Construct a console widget.
     */
    constructor(session: INotebookSession, rendermime: RenderMime<Widget>);
    prompt: CodeCellWidget;
    /**
     * Get the session used by the console.
     *
     * #### Notes
     * This is a read-only property.
     */
    session: INotebookSession;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Execute the current prompt.
     */
    execute(): Promise<void>;
    /**
     * Clear the code cells.
     */
    clear(): void;
    /**
     * Serialize the output.
     */
    serialize(): nbformat.ICodeCell[];
    /**
     * Handle `after_attach` messages for the widget.
     */
    protected onAfterAttach(msg: Message): void;
    /**
     * Handle `update_request` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Make a new prompt.
     */
    protected newPrompt(): void;
    /**
     * Initialize the banner and mimetype.
     */
    protected initialize(): void;
    /**
     * Handle a text changed signal from an editor.
     */
    protected onTextChange(editor: CellEditorWidget, change: ITextChange): void;
    /**
     * Update the tooltip based on a text change.
     */
    protected updateTooltip(change: ITextChange): void;
    /**
     * Show the tooltip.
     */
    protected showTooltip(change: ITextChange, bundle: nbformat.MimeBundle): void;
    /**
     * Handle a completion requested signal from an editor.
     */
    protected onCompletionRequest(editor: CellEditorWidget, change: ICompletionRequest): void;
    /**
     * Handle an edge requested signal.
     */
    protected onEdgeRequest(editor: CellEditorWidget, location: EdgeLocation): void;
    /**
     * Handle a completion selected signal from the completion widget.
     */
    protected onCompletionSelect(widget: CompletionWidget, value: string): void;
    private _completion;
    private _mimetype;
    private _rendermime;
    private _tooltip;
    private _history;
    private _session;
    private _pendingComplete;
    private _pendingInspect;
}
