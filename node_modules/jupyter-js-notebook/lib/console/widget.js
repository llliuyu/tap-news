// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var jupyter_js_services_1 = require('jupyter-js-services');
var dialog_1 = require('jupyter-js-ui/lib/dialog');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
var phosphor_panel_1 = require('phosphor-panel');
var cells_1 = require('../cells');
var mimetype_1 = require('../common/mimetype');
var tooltip_1 = require('./tooltip');
var history_1 = require('./history');
var completion_1 = require('../completion');
/**
 * The class name added to console widgets.
 */
var CONSOLE_CLASS = 'jp-Console';
/**
 * The class name added to console panels.
 */
var CONSOLE_PANEL = 'jp-Console-panel';
/**
 * The class name added to the console banner.
 */
var BANNER_CLASS = 'jp-Console-banner';
/**
 * A panel which contains a toolbar and a console.
 */
var ConsolePanel = (function (_super) {
    __extends(ConsolePanel, _super);
    /**
     * Construct a console panel.
     */
    function ConsolePanel(session, rendermime) {
        _super.call(this);
        this._console = null;
        this.addClass(CONSOLE_PANEL);
        var constructor = this.constructor;
        this._console = constructor.createConsole(session, rendermime);
        this.addChild(this._console);
    }
    /**
     * Create a new console widget for the panel.
     */
    ConsolePanel.createConsole = function (session, rendermime) {
        return new ConsoleWidget(session, rendermime);
    };
    Object.defineProperty(ConsolePanel.prototype, "content", {
        /**
         * The console widget used by the panel.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._console;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    ConsolePanel.prototype.dispose = function () {
        this._console = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    ConsolePanel.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                var prompt_1 = this.content.prompt;
                if (prompt_1) {
                    prompt_1.focus();
                }
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after_attach` messages for the widget.
     */
    ConsolePanel.prototype.onAfterAttach = function (msg) {
        this.content.node.addEventListener('click', this);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    ConsolePanel.prototype.onBeforeDetach = function (msg) {
        this.content.node.removeEventListener('click', this);
    };
    /**
     * Handle `'close-request'` messages.
     */
    ConsolePanel.prototype.onCloseRequest = function (msg) {
        var _this = this;
        var session = this.content.session;
        if (!session.kernel) {
            this.dispose();
        }
        session.kernel.getKernelSpec().then(function (spec) {
            var name = spec.display_name;
            return dialog_1.showDialog({
                title: 'Shut down kernel?',
                body: "Shut down " + name + "?",
                host: _this.node
            });
        }).then(function (value) {
            if (value && value.text === 'OK') {
                return session.shutdown();
            }
        }).then(function () {
            _super.prototype.onCloseRequest.call(_this, msg);
            _this.dispose();
        });
    };
    return ConsolePanel;
}(phosphor_panel_1.Panel));
exports.ConsolePanel = ConsolePanel;
/**
 * A widget containing a Jupyter console.
 */
var ConsoleWidget = (function (_super) {
    __extends(ConsoleWidget, _super);
    /**
     * Construct a console widget.
     */
    function ConsoleWidget(session, rendermime) {
        var _this = this;
        _super.call(this);
        this._completion = null;
        this._mimetype = 'text/x-ipython';
        this._rendermime = null;
        this._tooltip = null;
        this._history = null;
        this._session = null;
        this._pendingComplete = 0;
        this._pendingInspect = 0;
        this.addClass(CONSOLE_CLASS);
        var constructor = this.constructor;
        var layout = new phosphor_panel_1.PanelLayout();
        this.layout = layout;
        this._rendermime = rendermime;
        this._session = session;
        this._history = constructor.createHistory(session.kernel);
        // Instantiate tab completion widget.
        this._completion = constructor.createCompletion();
        this._completion.reference = this;
        this._completion.attach(document.body);
        this._completion.selected.connect(this.onCompletionSelect, this);
        // Instantiate tooltip widget.
        this._tooltip = constructor.createTooltip();
        this._tooltip.attach(document.body);
        // Create the banner.
        var banner = constructor.createBanner();
        banner.addClass(BANNER_CLASS);
        banner.readOnly = true;
        banner.model.source = '...';
        layout.addChild(banner);
        // Set the banner text and the mimetype.
        this.initialize();
        // Create the prompt.
        this.newPrompt();
        // Handle changes to the kernel.
        session.kernelChanged.connect(function (s, kernel) {
            _this.clear();
            _this.newPrompt();
            _this.initialize();
            _this._history = constructor.createHistory(kernel);
        });
    }
    /**
     * Create a new banner widget given a banner model.
     */
    ConsoleWidget.createBanner = function () {
        var model = new cells_1.RawCellModel();
        return new cells_1.RawCellWidget(model);
    };
    /**
     * Create a new prompt widget given a prompt model and a rendermime.
     */
    ConsoleWidget.createPrompt = function (rendermime) {
        var model = new cells_1.CodeCellModel();
        return new cells_1.CodeCellWidget(model, rendermime);
    };
    /**
     * Create a new completion widget.
     */
    ConsoleWidget.createCompletion = function () {
        var model = new completion_1.CompletionModel();
        return new completion_1.CompletionWidget(model);
    };
    /**
     * Create a console history.
     */
    ConsoleWidget.createHistory = function (kernel) {
        return new history_1.ConsoleHistory(kernel);
    };
    /**
     * Create a new tooltip widget.
     *
     * @returns A ConsoleTooltip widget.
     */
    ConsoleWidget.createTooltip = function () {
        return new tooltip_1.ConsoleTooltip();
    };
    Object.defineProperty(ConsoleWidget.prototype, "prompt", {
        /*
         * The last cell in a console is always a `CodeCellWidget` prompt.
         */
        get: function () {
            var layout = this.layout;
            var last = layout.childCount() - 1;
            return last > 0 ? layout.childAt(last) : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ConsoleWidget.prototype, "session", {
        /**
         * Get the session used by the console.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._session;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    ConsoleWidget.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        this._tooltip.dispose();
        this._tooltip = null;
        this._history.dispose();
        this._history = null;
        this._completion.dispose();
        this._completion = null;
        this._session.dispose();
        this._session = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Execute the current prompt.
     */
    ConsoleWidget.prototype.execute = function () {
        var _this = this;
        if (this._session.status === jupyter_js_services_1.KernelStatus.Dead) {
            return;
        }
        var prompt = this.prompt;
        prompt.trusted = true;
        this._history.push(prompt.model.source);
        return prompt.execute(this._session.kernel).then(function () { return _this.newPrompt(); }, function () { return _this.newPrompt(); });
    };
    /**
     * Clear the code cells.
     */
    ConsoleWidget.prototype.clear = function () {
        while (this.prompt) {
            this.prompt.dispose();
        }
        this.newPrompt();
    };
    /**
     * Serialize the output.
     */
    ConsoleWidget.prototype.serialize = function () {
        var output = [];
        var layout = this.layout;
        for (var i = 1; i < layout.childCount(); i++) {
            var widget = layout.childAt(i);
            output.push(widget.model.toJSON());
        }
        return output;
    };
    /**
     * Handle `after_attach` messages for the widget.
     */
    ConsoleWidget.prototype.onAfterAttach = function (msg) {
        var prompt = this.prompt;
        if (prompt) {
            prompt.focus();
        }
    };
    /**
     * Handle `update_request` messages.
     */
    ConsoleWidget.prototype.onUpdateRequest = function (msg) {
        var prompt = this.prompt;
        Private.scrollIfNeeded(this.parent.node, prompt.node);
    };
    /**
     * Make a new prompt.
     */
    ConsoleWidget.prototype.newPrompt = function () {
        // Make the previous editor read-only and clear its signals.
        var prompt = this.prompt;
        if (prompt) {
            prompt.readOnly = true;
            phosphor_signaling_1.clearSignalData(prompt.editor);
        }
        // Create the new prompt and add to layout.
        var layout = this.layout;
        var constructor = this.constructor;
        prompt = constructor.createPrompt(this._rendermime);
        prompt.mimetype = this._mimetype;
        layout.addChild(prompt);
        // Hook up completion, tooltip, and history handling.
        var editor = prompt.editor;
        editor.textChanged.connect(this.onTextChange, this);
        editor.completionRequested.connect(this.onCompletionRequest, this);
        editor.edgeRequested.connect(this.onEdgeRequest, this);
        prompt.focus();
    };
    /**
     * Initialize the banner and mimetype.
     */
    ConsoleWidget.prototype.initialize = function () {
        var _this = this;
        var layout = this.layout;
        var banner = layout.childAt(0);
        this._session.kernel.kernelInfo().then(function (info) {
            banner.model.source = info.banner;
            _this._mimetype = mimetype_1.mimetypeForLanguage(info.language_info);
            _this.prompt.mimetype = _this._mimetype;
        });
    };
    /**
     * Handle a text changed signal from an editor.
     */
    ConsoleWidget.prototype.onTextChange = function (editor, change) {
        var line = change.newValue.split('\n')[change.line];
        var lastChar = change.ch - 1;
        var model = this._completion.model;
        var hasCompletion = !!model.original;
        // If last character entered is not whitespace, update completion.
        if (line[lastChar] && line[lastChar].match(/\S/) && hasCompletion) {
            // Update the current completion state.
            model.current = change;
        }
        else {
            // If final character is whitespace, reset completion.
            model.options = null;
            model.original = null;
            model.cursor = null;
        }
        // Displaying completion widget overrides displaying tooltip.
        if (hasCompletion) {
            this._tooltip.hide();
        }
        else if (change.newValue) {
            this.updateTooltip(change);
        }
    };
    /**
     * Update the tooltip based on a text change.
     */
    ConsoleWidget.prototype.updateTooltip = function (change) {
        var _this = this;
        var line = change.newValue.split('\n')[change.line];
        var contents = { code: line, cursor_pos: change.ch, detail_level: 0 };
        var pendingInspect = ++this._pendingInspect;
        this._session.kernel.inspect(contents).then(function (value) {
            // If widget has been disposed, bail.
            if (_this.isDisposed) {
                return;
            }
            // If a newer text change has created a pending request, bail.
            if (pendingInspect !== _this._pendingInspect) {
                return;
            }
            // Tooltip request failures or negative results fail silently.
            if (value.status !== 'ok' || !value.found) {
                return;
            }
            var bundle = Private.processInspectReply(value.data);
            _this.showTooltip(change, bundle);
        });
    };
    /**
     * Show the tooltip.
     */
    ConsoleWidget.prototype.showTooltip = function (change, bundle) {
        var _a = change.coords, top = _a.top, bottom = _a.bottom, left = _a.left;
        var tooltip = this._tooltip;
        var heightAbove = top + 1; // 1px border
        var heightBelow = window.innerHeight - bottom - 1; // 1px border
        var widthLeft = left;
        var widthRight = window.innerWidth - left;
        // Add content and measure.
        tooltip.content = this._rendermime.render(bundle);
        tooltip.show();
        var _b = tooltip.node.getBoundingClientRect(), width = _b.width, height = _b.height;
        var maxWidth;
        var maxHeight;
        // Prefer displaying below.
        if (heightBelow >= height || heightBelow >= heightAbove) {
            // Offset the height of the tooltip by the height of cursor characters.
            top += change.chHeight;
            maxHeight = heightBelow;
        }
        else {
            maxHeight = heightAbove;
            top -= Math.min(height, maxHeight);
        }
        // Prefer displaying on the right.
        if (widthRight >= width || widthRight >= widthLeft) {
            // Account for 1px border width.
            left += 1;
            maxWidth = widthRight;
        }
        else {
            maxWidth = widthLeft;
            left -= Math.min(width, maxWidth);
        }
        tooltip.node.style.top = top + "px";
        tooltip.node.style.left = left + "px";
        tooltip.node.style.maxHeight = maxHeight + "px";
        tooltip.node.style.maxWidth = maxWidth + "px";
    };
    /**
     * Handle a completion requested signal from an editor.
     */
    ConsoleWidget.prototype.onCompletionRequest = function (editor, change) {
        var _this = this;
        var contents = {
            // Only send the current line of code for completion.
            code: change.currentValue.split('\n')[change.line],
            cursor_pos: change.ch
        };
        var pendingComplete = ++this._pendingComplete;
        var model = this._completion.model;
        this._session.kernel.complete(contents).then(function (value) {
            // If model has been disposed, bail.
            if (model.isDisposed) {
                return;
            }
            // If a newer completion requesy has created a pending request, bail.
            if (pendingComplete !== _this._pendingComplete) {
                return;
            }
            // Completion request failures or negative results fail silently.
            if (value.status !== 'ok') {
                return;
            }
            // Update the model.
            model.options = value.matches;
            model.cursor = { start: value.cursor_start, end: value.cursor_end };
        }).then(function () {
            model.original = change;
        });
    };
    /**
     * Handle an edge requested signal.
     */
    ConsoleWidget.prototype.onEdgeRequest = function (editor, location) {
        var doc = editor.editor.getDoc();
        if (location === 'top') {
            this._history.back().then(function (value) {
                if (!value) {
                    return;
                }
                doc.setValue(value);
                doc.setCursor(doc.posFromIndex(0));
            });
        }
        else {
            this._history.forward().then(function (value) {
                // If at the bottom end of history, then clear the prompt.
                var text = value || '';
                doc.setValue(text);
                doc.setCursor(doc.posFromIndex(text.length));
            });
        }
    };
    /**
     * Handle a completion selected signal from the completion widget.
     */
    ConsoleWidget.prototype.onCompletionSelect = function (widget, value) {
        var prompt = this.prompt;
        var patch = this._completion.model.createPatch(value);
        prompt.model.source = patch.text;
        prompt.editor.setCursorPosition(patch.position);
    };
    return ConsoleWidget;
}(phosphor_widget_1.Widget));
exports.ConsoleWidget = ConsoleWidget;
/**
 * A namespace for Console widget private data.
 */
var Private;
(function (Private) {
    /**
     * Scroll an element into view if needed.
     *
     * @param area - The scroll area element.
     *
     * @param elem - The element of interest.
     */
    function scrollIfNeeded(area, elem) {
        var ar = area.getBoundingClientRect();
        var er = elem.getBoundingClientRect();
        if (er.top < ar.top - 10) {
            area.scrollTop -= ar.top - er.top + 10;
        }
        else if (er.bottom > ar.bottom + 10) {
            area.scrollTop += er.bottom - ar.bottom + 10;
        }
    }
    Private.scrollIfNeeded = scrollIfNeeded;
    /**
     * Process the IInspectReply plain text data.
     *
     * @param bundle - The MIME bundle of an API inspect reply.
     *
     * #### Notes
     * The `text/plain` value sent by the API in inspect replies contains ANSI
     * terminal escape sequences. In order for these sequences to be parsed into
     * usable data in the client, they must have the MIME type that the console
     * text renderer expects: `application/vnd.jupyter.console-text`.
     */
    function processInspectReply(bundle) {
        var textMime = 'text/plain';
        var consoleMime = 'application/vnd.jupyter.console-text';
        bundle[consoleMime] = bundle[consoleMime] || bundle[textMime];
        return bundle;
    }
    Private.processInspectReply = processInspectReply;
})(Private || (Private = {}));
