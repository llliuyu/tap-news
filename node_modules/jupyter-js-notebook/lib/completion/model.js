// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var phosphor_signaling_1 = require('phosphor-signaling');
/**
 * An implementation of a completion model.
 */
var CompletionModel = (function () {
    function CompletionModel() {
        this._isDisposed = false;
        this._options = null;
        this._original = null;
        this._current = null;
        this._query = '';
        this._cursor = null;
    }
    Object.defineProperty(CompletionModel.prototype, "isDisposed", {
        /**
         * Get whether the model is disposed.
         */
        get: function () {
            return this._isDisposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "stateChanged", {
        /**
         * A signal emitted when state of the completion menu changes.
         */
        get: function () {
            return Private.stateChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "cursor", {
        /**
         * The cursor details that the API has used to return matching options.
         */
        get: function () {
            return this._cursor;
        },
        set: function (cursor) {
            this._cursor = cursor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "items", {
        /**
         * The list of visible items in the completion menu.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._filter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "options", {
        /**
         * The unfiltered list of all available options in a completion menu.
         */
        get: function () {
            return this._options;
        },
        set: function (newValue) {
            if (newValue) {
                this._options = [];
                (_a = this._options).push.apply(_a, newValue);
            }
            else {
                this._options = null;
            }
            this.stateChanged.emit(void 0);
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "original", {
        /**
         * The original completion request details.
         */
        get: function () {
            return this._original;
        },
        set: function (request) {
            this._original = request;
            this._current = null;
            this.stateChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionModel.prototype, "current", {
        /**
         * The current text change details.
         */
        get: function () {
            return this._current;
        },
        set: function (newValue) {
            this._current = newValue;
            var original = this._original;
            var current = this._current;
            var originalLine = original.currentValue.split('\n')[original.line];
            var currentLine = current.newValue.split('\n')[current.line];
            // If the text change means that the original start point has been preceded,
            // then the completion is no longer valid and should be reset.
            if (currentLine.length < originalLine.length) {
                console.log('A');
                this.reset();
            }
            else {
                var _a = this._cursor, start = _a.start, end = _a.end;
                // Clip the front of the current line.
                var query = currentLine.substring(start);
                // Clip the back of the current line.
                var ending = originalLine.substring(end);
                query = query.substring(0, query.lastIndexOf(ending));
                this._query = query;
            }
            this.stateChanged.emit(void 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create a resolved patch between the original state and a patch string.
     *
     * @param patch - The patch string to apply to the original value.
     *
     * @returns A patched text change or null if original value did not exist.
     *
     * #### Notes
     * The coords field is set to null because it is calculated by the editor, so
     * a patched version cannot reliably produce accurate coordinates for the
     * cursor.
     */
    CompletionModel.prototype.createPatch = function (patch) {
        var original = this._original;
        var cursor = this._cursor;
        if (!original || !cursor) {
            return null;
        }
        var start = cursor.start, end = cursor.end;
        var lines = original.currentValue.split('\n');
        var line = lines[original.line];
        var prefix = line.substring(0, start);
        var suffix = line.substring(end);
        lines[original.line] = prefix + patch + suffix;
        var text = lines.join('\n');
        // Add current line to position.
        var position = prefix.length + patch.length;
        // Add all the preceding lines lengths to position.
        for (var i = 0; i < original.line; i++) {
            // Add an extra character for the line break.
            position += lines[i].length + 1;
        }
        return { position: position, text: text };
    };
    /**
     * Dispose of the resources held by the model.
     */
    CompletionModel.prototype.dispose = function () {
        // Do nothing if already disposed.
        if (this.isDisposed) {
            return;
        }
        phosphor_signaling_1.clearSignalData(this);
        this._isDisposed = true;
    };
    /**
     * Reset the state of the model.
     */
    CompletionModel.prototype.reset = function () {
        this.original = null;
        this.options = null;
        this._query = '';
        this._cursor = null;
    };
    /**
     * Apply the query to the complete options list to return the matching subset.
     */
    CompletionModel.prototype._filter = function () {
        var options = this._options || [];
        var query = this._query;
        if (!query) {
            return options.map(function (option) { return ({ raw: option, text: option }); });
        }
        var results = [];
        for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
            var option = options_1[_i];
            var match = StringSearch.sumOfSquares(option, query);
            if (match) {
                results.push({
                    raw: option,
                    score: match.score,
                    text: StringSearch.highlight(option, match.indices)
                });
            }
        }
        return results.sort(function (a, b) { return a.score - b.score; })
            .map(function (result) { return ({ text: result.text, raw: result.raw }); });
    };
    return CompletionModel;
}());
exports.CompletionModel = CompletionModel;
/**
 * A namespace for completion model private data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when state of the completion menu changes.
     */
    Private.stateChangedSignal = new phosphor_signaling_1.Signal();
})(Private || (Private = {}));
/**
 * A namespace which holds string searching functionality.
 *
 * #### Notes
 * This functionality comes from phosphor-core and can be removed from this file
 * once newer versions of phosphor libraries are used throughout
 * jupyter-js-notebook.
 */
var StringSearch;
(function (StringSearch) {
    /**
     * Compute the sum-of-squares match for the given search text.
     *
     * @param sourceText - The text which should be searched.
     *
     * @param queryText - The query text to locate in the source text.
     *
     * @returns The match result object, or `null` if there is no match.
     *
     * #### Complexity
     * Linear on `sourceText`.
     *
     * #### Notes
     * This scoring algorithm uses a sum-of-squares approach to determine
     * the score. In order for there to be a match, all of the characters
     * in `queryText` **must** appear in `sourceText` in order. The index
     * of each matching character is squared and added to the score. This
     * means that early and consecutive character matches are preferred.
     *
     * The character match is performed with strict equality. It is case
     * sensitive and does not ignore whitespace. If those behaviors are
     * required, the text should be transformed before scoring.
     */
    function sumOfSquares(sourceText, queryText) {
        var score = 0;
        var indices = new Array(queryText.length);
        for (var i = 0, j = 0, n = queryText.length; i < n; ++i, ++j) {
            j = sourceText.indexOf(queryText[i], j);
            if (j === -1) {
                return null;
            }
            indices[i] = j;
            score += j * j;
        }
        return { score: score, indices: indices };
    }
    StringSearch.sumOfSquares = sumOfSquares;
    /**
     * Highlight the matched characters of a source string.
     *
     * @param source - The text which should be highlighted.
     *
     * @param indices - The indices of the matched characters. They must
     *   appear in increasing order and must be in bounds of the source.
     *
     * @returns A string with interpolated `<mark>` tags.
     */
    function highlight(sourceText, indices) {
        var k = 0;
        var last = 0;
        var result = '';
        var n = indices.length;
        while (k < n) {
            var i = indices[k];
            var j = indices[k];
            while (++k < n && indices[k] === j + 1) {
                j++;
            }
            var head = sourceText.slice(last, i);
            var chunk = sourceText.slice(i, j + 1);
            result += head + "<mark>" + chunk + "</mark>";
            last = j + 1;
        }
        return result + sourceText.slice(last);
    }
    StringSearch.highlight = highlight;
})(StringSearch || (StringSearch = {}));
