// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
/**
 * The class name added to completion menu widgets.
 */
var COMPLETION_CLASS = 'jp-Completion';
/**
 * The class name added to completion menu items.
 */
var ITEM_CLASS = 'jp-Completion-item';
/**
 * The class name added to an active completion menu item.
 */
var ACTIVE_CLASS = 'jp-mod-active';
/**
 * The maximum height of a completion widget.
 */
var MAX_HEIGHT = 250;
/**
 * A widget that enables text completion.
 */
var CompletionWidget = (function (_super) {
    __extends(CompletionWidget, _super);
    /**
     * Construct a text completion menu widget.
     */
    function CompletionWidget(model) {
        var _this = this;
        _super.call(this);
        this._activeIndex = 0;
        this._model = null;
        this._reference = null;
        this._model = model;
        this._model.stateChanged.connect(function () { return _this.update(); }, this);
        this.addClass(COMPLETION_CLASS);
        this.update();
    }
    /**
     * Create the DOM node for a text completion menu.
     */
    CompletionWidget.createNode = function () {
        var node = document.createElement('ul');
        return node;
    };
    /**
     * Create an item node for a text completion menu.
     */
    CompletionWidget.createItemNode = function (item) {
        var li = document.createElement('li');
        var code = document.createElement('code');
        // Set the raw, un-marked up value as a data attribute.
        li.dataset['value'] = item.raw;
        // Use innerHTML because search results include <mark> tags.
        code.innerHTML = item.text;
        li.className = ITEM_CLASS;
        li.appendChild(code);
        return li;
    };
    Object.defineProperty(CompletionWidget.prototype, "selected", {
        /**
         * A signal emitted when a selection is made from the completion menu.
         */
        get: function () {
            return Private.selectedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionWidget.prototype, "model", {
        /**
         * The model used by the completion widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompletionWidget.prototype, "reference", {
        /**
         * The semantic parent of the completion widget, its reference widget.
         */
        get: function () {
            return this._reference;
        },
        set: function (widget) {
            this._reference = widget;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the completion widget.
     */
    CompletionWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._model.dispose();
        this._model = null;
        phosphor_signaling_1.clearSignalData(this);
        _super.prototype.dispose.call(this);
    };
    /**
     * Handle the DOM events for the widget.
     *
     * @param event - The DOM event sent to the widget.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the dock panel's node. It should
     * not be called directly by user code.
     */
    CompletionWidget.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'keydown':
                this._evtKeydown(event);
                break;
            case 'mousedown':
                this._evtMousedown(event);
                break;
            case 'scroll':
                this._evtScroll(event);
                break;
            default:
                break;
        }
    };
    /**
     * Handle `after_attach` messages for the widget.
     *
     * #### Notes
     * Captures window events in capture phase to dismiss or navigate the
     * completion widget.
     *
     * Because its parent (reference) widgets use window listeners instead of
     * document listeners, the completion widget must also use window listeners
     * in the capture phase.
     */
    CompletionWidget.prototype.onAfterAttach = function (msg) {
        window.addEventListener('keydown', this, true);
        window.addEventListener('mousedown', this, true);
        window.addEventListener('scroll', this, true);
    };
    /**
     * Handle `before_detach` messages for the widget.
     */
    CompletionWidget.prototype.onBeforeDetach = function (msg) {
        window.removeEventListener('keydown', this);
        window.removeEventListener('mousedown', this);
        window.removeEventListener('scroll', this);
    };
    /**
     * Handle `update_request` messages.
     */
    CompletionWidget.prototype.onUpdateRequest = function (msg) {
        var node = this.node;
        var items = this._model.items;
        var constructor = this.constructor;
        node.textContent = '';
        // All repaints reset the index back to 0.
        this._activeIndex = 0;
        if (!items || !items.length) {
            this.hide();
            return;
        }
        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
            var item = items_1[_i];
            node.appendChild(constructor.createItemNode(item));
        }
        var active = node.querySelectorAll("." + ITEM_CLASS)[this._activeIndex];
        active.classList.add(ACTIVE_CLASS);
        if (this.isHidden) {
            this.show();
        }
        var coords = this._model.current ? this._model.current.coords
            : this._model.original.coords;
        var availableHeight = coords.top;
        var maxHeight = Math.min(availableHeight, MAX_HEIGHT);
        node.style.maxHeight = maxHeight + "px";
        // Account for 1px border width.
        var left = Math.floor(coords.left) + 1;
        var rect = node.getBoundingClientRect();
        var top = availableHeight - rect.height;
        node.style.left = left + "px";
        node.style.top = top + "px";
        node.style.width = 'auto';
        // Expand the menu width by the scrollbar size, if present.
        if (node.scrollHeight > maxHeight) {
            node.style.width = (2 * node.offsetWidth - node.clientWidth) + "px";
            node.scrollTop = 0;
        }
    };
    /**
     * Handle mousedown events for the widget.
     */
    CompletionWidget.prototype._evtMousedown = function (event) {
        if (!this._reference || this.isHidden || Private.nonstandardClick(event)) {
            this.hide();
            return;
        }
        var target = event.target;
        while (target !== document.documentElement) {
            // If the user has made a selection, emit its value and reset the model.
            if (target.classList.contains(ITEM_CLASS)) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                this.selected.emit(target.dataset['value']);
                this._model.reset();
                return;
            }
            // If the mouse event happened anywhere else in the widget, bail.
            if (target === this.node) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
                return;
            }
            target = target.parentElement;
        }
        this._model.reset();
    };
    /**
     * Handle keydown events for the widget.
     */
    CompletionWidget.prototype._evtKeydown = function (event) {
        if (!this._reference || this.isHidden) {
            this.hide();
            return;
        }
        var target = event.target;
        var node = this.node;
        var active;
        while (target !== document.documentElement) {
            if (target === this._reference.node) {
                switch (event.keyCode) {
                    case 13: // Enter key
                    case 9:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        active = node.querySelector("." + ACTIVE_CLASS);
                        this.selected.emit(active.dataset['value']);
                        this._model.reset();
                        return;
                    case 27:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        this._model.reset();
                        return;
                    case 38: // Up arrow key
                    case 40:
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                        var items = this.node.querySelectorAll("." + ITEM_CLASS);
                        active = node.querySelector("." + ACTIVE_CLASS);
                        active.classList.remove(ACTIVE_CLASS);
                        this._activeIndex = event.keyCode === 38 ?
                            Math.max(--this._activeIndex, 0)
                            : Math.min(++this._activeIndex, items.length - 1);
                        active = items[this._activeIndex];
                        active.classList.add(ACTIVE_CLASS);
                        Private.scrollIfNeeded(this.node, active);
                        return;
                    default:
                        return;
                }
            }
            target = target.parentElement;
        }
        this.hide();
    };
    /**
     * Handle scroll events for the widget
     */
    CompletionWidget.prototype._evtScroll = function (event) {
        if (!this._reference || this.isHidden) {
            this.hide();
            return;
        }
        var target = event.target;
        while (target !== document.documentElement) {
            // If the scroll event happened in the completion widget, allow it.
            if (target === this.node) {
                return;
            }
            target = target.parentElement;
        }
        this.hide();
    };
    return CompletionWidget;
}(phosphor_widget_1.Widget));
exports.CompletionWidget = CompletionWidget;
/**
 * A namespace for completion widget private data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when state of the completion menu changes.
     */
    Private.selectedSignal = new phosphor_signaling_1.Signal();
    /**
     * Returns true for any modified click event (i.e., not a left-click).
     */
    function nonstandardClick(event) {
        return event.button !== 0 ||
            event.altKey ||
            event.ctrlKey ||
            event.shiftKey ||
            event.metaKey;
    }
    Private.nonstandardClick = nonstandardClick;
    /**
     * Scroll an element into view if needed.
     *
     * @param area - The scroll area element.
     *
     * @param elem - The element of interest.
     */
    function scrollIfNeeded(area, elem) {
        var ar = area.getBoundingClientRect();
        var er = elem.getBoundingClientRect();
        if (er.top < ar.top - 10) {
            area.scrollTop -= ar.top - er.top + 10;
        }
        else if (er.bottom > ar.bottom + 10) {
            area.scrollTop += er.bottom - ar.bottom + 10;
        }
    }
    Private.scrollIfNeeded = scrollIfNeeded;
})(Private || (Private = {}));
