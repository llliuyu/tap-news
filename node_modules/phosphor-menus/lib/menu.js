/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
var base_1 = require('./base');
var menuitem_1 = require('./menuitem');
/**
 * The class name added to Menu instances.
 */
var MENU_CLASS = 'p-Menu';
/**
 * The class name added to a menu content node.
 */
var CONTENT_CLASS = 'p-Menu-content';
/**
 * The class name added to a menu item node.
 */
var ITEM_CLASS = 'p-Menu-item';
/**
 * The class name added to a menu item icon cell.
 */
var ICON_CLASS = 'p-Menu-itemIcon';
/**
 * The class name added to a menu item text cell.
 */
var TEXT_CLASS = 'p-Menu-itemText';
/**
 * The class name added to a menu item shortcut cell.
 */
var SHORTCUT_CLASS = 'p-Menu-itemShortcut';
/**
 * The class name added to a menu item submenu icon cell.
 */
var SUBMENU_CLASS = 'p-Menu-itemSubmenuIcon';
/**
 * The class name added to a check type menu item.
 */
var CHECK_TYPE_CLASS = 'p-type-check';
/**
 * The class name added to a separator type menu item.
 */
var SEPARATOR_TYPE_CLASS = 'p-type-separator';
/**
 * The class name added to a submenu type menu item.
 */
var SUBMENU_TYPE_CLASS = 'p-type-submenu';
/**
 * The class name added to active menu items.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled menu item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a checked menu item.
 */
var CHECKED_CLASS = 'p-mod-checked';
/**
 * The class name added to a hidden menu item.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The ms delay for opening a submenu.
 */
var OPEN_DELAY = 300;
/**
 * The ms delay for closing a submenu.
 */
var CLOSE_DELAY = 300;
/**
 * The horizontal px overlap for open submenus.
 */
var SUBMENU_OVERLAP = 3;
/**
 * A widget which displays menu items as a popup menu.
 */
var Menu = (function (_super) {
    __extends(Menu, _super);
    /**
     * Construct a new menu.
     *
     * @param items - Optional menu items to initialize the menu.
     *
     * #### Notes
     * Subclasses should not pass menu items to `super`. The subclass
     * should set its own items after it has been fully initialized.
     */
    function Menu(items) {
        _super.call(this);
        this._openTimerId = 0;
        this._closeTimerId = 0;
        this._parentMenu = null;
        this._childMenu = null;
        this._childItem = null;
        this._nodes = [];
        this.addClass(MENU_CLASS);
        if (items)
            this.items = items;
    }
    /**
     * Create the DOM node for a menu.
     */
    Menu.createNode = function () {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        return node;
    };
    /**
     * Create a new item node for a menu.
     *
     * @returns A new DOM node to use as an item in a menu.
     *
     * #### Notes
     * This method may be reimplemented to create custom items.
     */
    Menu.createItemNode = function () {
        var node = document.createElement('li');
        var icon = document.createElement('span');
        var text = document.createElement('span');
        var shortcut = document.createElement('span');
        var submenu = document.createElement('span');
        node.className = ITEM_CLASS;
        text.className = TEXT_CLASS;
        shortcut.className = SHORTCUT_CLASS;
        submenu.className = SUBMENU_CLASS;
        node.appendChild(icon);
        node.appendChild(text);
        node.appendChild(shortcut);
        node.appendChild(submenu);
        return node;
    };
    /**
     * Update an item node to reflect the current state of a menu item.
     *
     * @param node - A node created by a call to [[createItemNode]].
     *
     * @param item - The menu item to use for the item state.
     *
     * #### Notes
     * This is called automatically when the item should be updated.
     *
     * If the [[createItemNode]] method is reimplemented, this method
     * should also be reimplemented so that the item state is properly
     * updated.
     */
    Menu.updateItemNode = function (node, item) {
        var sep = item.type === menuitem_1.MenuItem.Separator;
        var sub = item.type === menuitem_1.MenuItem.Submenu;
        var icon = node.firstChild;
        var text = icon.nextSibling;
        var shortcut = text.nextSibling;
        node.className = MenuPrivate.createItemClass(item);
        icon.className = ICON_CLASS + (item.icon ? ' ' + item.icon : '');
        text.textContent = sep ? '' : item.text.replace(/&/g, '');
        shortcut.textContent = (sep || sub) ? '' : item.shortcut;
    };
    /**
     * Dispose of the resources held by the menu.
     */
    Menu.prototype.dispose = function () {
        this.close();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(Menu.prototype, "closed", {
        /**
         * A signal emitted when the menu item is closed.
         */
        get: function () {
            return MenuPrivate.closedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "parentMenu", {
        /**
         * Get the parent menu of the menu.
         *
         * #### Notes
         * This will be `null` if the menu is not an open submenu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._parentMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "childMenu", {
        /**
         * Get the child menu of the menu.
         *
         * #### Notes
         * This will be `null` if the menu does not have an open submenu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "rootMenu", {
        /**
         * Find the root menu of this menu hierarchy.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var menu = this;
            while (menu._parentMenu) {
                menu = menu._parentMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "leafMenu", {
        /**
         * Find the leaf menu of this menu hierarchy.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            var menu = this;
            while (menu._childMenu) {
                menu = menu._childMenu;
            }
            return menu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Menu.prototype, "contentNode", {
        /**
         * Get the menu content node.
         *
         * #### Notes
         * This is the node which holds the menu item nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the submenu of the active item, if possible.
     *
     * #### Notes
     * This is a no-op if the menu is not visible, if there is no active
     * item, or if the active item is disabled or has a null submenu.
     */
    Menu.prototype.openActiveItem = function () {
        if (!this.isVisible) {
            return;
        }
        var index = this.activeIndex;
        if (index === -1) {
            return;
        }
        var item = this.items[index];
        if (item.disabled || !item.submenu) {
            return;
        }
        this._openChildMenu(item, this._nodes[index], false);
        this._childMenu.activateNextItem();
    };
    /**
     * Trigger the handler of the active item, if possible.
     *
     * #### Notes
     * This is a no-op if the menu is not visible, if there is no
     * active item, or if the active item is disabled.
     */
    Menu.prototype.triggerActiveItem = function () {
        if (!this.isVisible) {
            return;
        }
        var index = this.activeIndex;
        if (index === -1) {
            return;
        }
        var item = this.items[index];
        if (item.disabled) {
            return;
        }
        if (item.submenu) {
            this._openChildMenu(item, this._nodes[index], false);
            this._childMenu.activateNextItem();
            return;
        }
        var handler = item.handler;
        if (!handler) {
            return;
        }
        this.rootMenu.close();
        handler(item);
    };
    /**
     * Popup the menu at the specified location.
     *
     * The menu will be opened at the given location unless it will not
     * fully fit on the screen. If it will not fit, it will be adjusted
     * to fit naturally on the screen. The last two optional parameters
     * control whether the provided coordinate value must be obeyed.
     *
     * When the menu is opened as a popup menu, it will handle all key
     * events related to menu navigation as well as closing the menu
     * when the mouse is pressed outside of the menu hierarchy. To
     * prevent these actions, use the [[open]] method instead.
     *
     * @param x - The client X coordinate of the popup location.
     *
     * @param y - The client Y coordinate of the popup location.
     *
     * @param forceX - Whether the X coordinate must be obeyed.
     *
     * @param forceY - Whether the Y coordinate must be obeyed.
     *
     * #### Notes
     * This is a no-op if the menu is already attached to the DOM.
     *
     * **See also:** [[open]]
     */
    Menu.prototype.popup = function (x, y, forceX, forceY) {
        if (forceX === void 0) { forceX = false; }
        if (forceY === void 0) { forceY = false; }
        if (!this.isAttached) {
            document.addEventListener('keydown', this, true);
            document.addEventListener('keypress', this, true);
            document.addEventListener('mousedown', this, true);
            MenuPrivate.openRootMenu(this, x, y, forceX, forceY);
        }
    };
    /**
     * Open the menu at the specified location.
     *
     * The menu will be opened at the given location unless it will not
     * fully fit on the screen. If it will not fit, it will be adjusted
     * to fit naturally on the screen. The last two optional parameters
     * control whether the provided coordinate value must be obeyed.
     *
     * When the menu is opened with this method, it will not handle key
     * events for navigation, nor will it close itself when the mouse is
     * pressed outside the menu hierarchy. This is useful when using the
     * menu from a menubar, where the menubar should handle these tasks.
     * Use the [[popup]] method for the alternative behavior.
     *
     * @param x - The client X coordinate of the popup location.
     *
     * @param y - The client Y coordinate of the popup location.
     *
     * @param forceX - Whether the X coordinate must be obeyed.
     *
     * @param forceY - Whether the Y coordinate must be obeyed.
     *
     * #### Notes
     * This is a no-op if the menu is already attached to the DOM.
     *
     * **See also:** [[popup]]
     */
    Menu.prototype.open = function (x, y, forceX, forceY) {
        if (forceX === void 0) { forceX = false; }
        if (forceY === void 0) { forceY = false; }
        if (!this.isAttached) {
            MenuPrivate.openRootMenu(this, x, y, forceX, forceY);
        }
    };
    /**
     * Handle the DOM events for the menu.
     *
     * @param event - The DOM event sent to the menu.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu's DOM nodes. It should
     * not be called directly by user code.
     */
    Menu.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'keypress':
                this._evtKeyPress(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A method invoked to test whether an item is selectable.
     *
     * @param item - The menu item of interest.
     *
     * @returns `true` if the item is selectable, `false` otherwise.
     */
    Menu.prototype.isSelectable = function (item) {
        if (item.disabled || item.type === menuitem_1.MenuItem.Separator) {
            return false;
        }
        if (item.type === menuitem_1.MenuItem.Submenu) {
            return !!item.submenu;
        }
        return !!item.handler;
    };
    /**
     * A method invoked when the menu items change.
     *
     * @param oldItems - The old menu items.
     *
     * @param newItems - The new menu items.
     */
    Menu.prototype.onItemsChanged = function (oldItems, newItems) {
        // Reset the menu before changing the items.
        this.close();
        // Fetch common variables.
        var nodes = this._nodes;
        var content = this.contentNode;
        var constructor = this.constructor;
        // Remove any excess item nodes.
        while (nodes.length > newItems.length) {
            var node = nodes.pop();
            content.removeChild(node);
        }
        // Add any missing item nodes.
        while (nodes.length < newItems.length) {
            var node = constructor.createItemNode();
            content.appendChild(node);
            nodes.push(node);
        }
        // An update is performed just before opening the menu, which
        // removes the need to connect the menu item `changed` signal.
    };
    /**
     * A method invoked when the active index changes.
     *
     * @param oldIndex - The old active index.
     *
     * @param newIndex - The new active index.
     */
    Menu.prototype.onActiveIndexChanged = function (oldIndex, newIndex) {
        var oldNode = this._nodes[oldIndex];
        var newNode = this._nodes[newIndex];
        if (oldNode)
            oldNode.classList.remove(ACTIVE_CLASS);
        if (newNode)
            newNode.classList.add(ACTIVE_CLASS);
    };
    /**
     * A message handler invoked on a `'close-request'` message.
     */
    Menu.prototype.onCloseRequest = function (msg) {
        // Reset the menu state.
        this._cancelPendingOpen();
        this._cancelPendingClose();
        this.activeIndex = -1;
        // Close any open child menu.
        var childMenu = this._childMenu;
        if (childMenu) {
            this._childMenu = null;
            this._childItem = null;
            childMenu._parentMenu = null;
            childMenu.close();
        }
        // Remove this menu from any parent.
        var parentMenu = this._parentMenu;
        if (parentMenu) {
            this._parentMenu = null;
            parentMenu._cancelPendingOpen();
            parentMenu._cancelPendingClose();
            parentMenu._childMenu = null;
            parentMenu._childItem = null;
        }
        // Ensure this menu is detached.
        if (this.parent) {
            this.parent = null;
            this.closed.emit(void 0);
        }
        else if (this.isAttached) {
            this.detach();
            this.closed.emit(void 0);
        }
    };
    /**
     * A handler invoked on an `'update-request'` message.
     */
    Menu.prototype.onUpdateRequest = function (msg) {
        // Fetch common variables.
        var items = this.items;
        var nodes = this._nodes;
        var constructor = this.constructor;
        // Update the state of the item nodes.
        for (var i = 0, n = items.length; i < n; ++i) {
            constructor.updateItemNode(nodes[i], items[i]);
        }
        // Restore the active node class.
        var active = nodes[this.activeIndex];
        if (active)
            active.classList.add(ACTIVE_CLASS);
        // Hide the redundant and useless menu item nodes.
        MenuPrivate.hideUselessItems(nodes, items);
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    Menu.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('mouseup', this);
        this.node.addEventListener('mousemove', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    Menu.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('mouseup', this);
        this.node.removeEventListener('mousemove', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keypress', this, true);
        document.removeEventListener('mousedown', this, true);
    };
    /**
     * Handle the `'mousemove'` event for the menu.
     */
    Menu.prototype._evtMouseMove = function (event) {
        var x = event.clientX;
        var y = event.clientY;
        var i = arrays.findIndex(this._nodes, function (node) { return phosphor_domutil_1.hitTest(node, x, y); });
        if (i === this.activeIndex) {
            return;
        }
        this.activeIndex = i;
        this._syncAncestors();
        this._closeChildMenu();
        this._cancelPendingOpen();
        var item = this.activeItem;
        if (item && item.submenu) {
            if (item === this._childItem) {
                this._cancelPendingClose();
            }
            else {
                this._openChildMenu(item, this._nodes[i], true);
            }
        }
    };
    /**
     * Handle the `'mouseleave'` event for the menu.
     */
    Menu.prototype._evtMouseLeave = function (event) {
        this._cancelPendingOpen();
        var x = event.clientX;
        var y = event.clientY;
        var child = this._childMenu;
        if (!child || !phosphor_domutil_1.hitTest(child.node, x, y)) {
            this.activeIndex = -1;
            this._closeChildMenu();
        }
    };
    /**
     * Handle the `'mousedown'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     *
     * This allows the event to propagate so the element under the mouse
     * can be focused without requiring a second click.
     */
    Menu.prototype._evtMouseDown = function (event) {
        var menu = this;
        var hit = false;
        var x = event.clientX;
        var y = event.clientY;
        while (!hit && menu) {
            hit = phosphor_domutil_1.hitTest(menu.node, x, y);
            menu = menu._childMenu;
        }
        if (!hit)
            this.close();
    };
    /**
     * Handle the `'mouseup'` event for the menu.
     */
    Menu.prototype._evtMouseUp = function (event) {
        if (event.button !== 0) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        var node = this._nodes[this.activeIndex];
        if (node && node.contains(event.target)) {
            this.triggerActiveItem();
        }
    };
    /**
     * Handle the `'keydown'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     */
    Menu.prototype._evtKeyDown = function (event) {
        event.stopPropagation();
        var leaf = this.leafMenu;
        switch (event.keyCode) {
            case 13:
                event.preventDefault();
                leaf.triggerActiveItem();
                break;
            case 27:
                event.preventDefault();
                leaf.close();
                break;
            case 37:
                event.preventDefault();
                if (leaf !== this)
                    leaf.close();
                break;
            case 38:
                event.preventDefault();
                leaf.activatePreviousItem();
                break;
            case 39:
                event.preventDefault();
                leaf.openActiveItem();
                break;
            case 40:
                event.preventDefault();
                leaf.activateNextItem();
                break;
        }
    };
    /**
     * Handle the `'keypress'` event for the menu.
     *
     * This event listener is attached to the document for a popup menu.
     */
    Menu.prototype._evtKeyPress = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var key = String.fromCharCode(event.charCode);
        this.leafMenu.activateMnemonicItem(key);
    };
    /**
     * Synchronize the active item hierarchy starting with the parent.
     *
     * This ensures that the proper child items are activated for the
     * ancestor menu hierarchy and that any pending open or close tasks
     * are canceled.
     */
    Menu.prototype._syncAncestors = function () {
        var menu = this._parentMenu;
        while (menu) {
            menu._syncChildItem();
            menu = menu._parentMenu;
        }
    };
    /**
     * Synchronize the active index with the current child item.
     */
    Menu.prototype._syncChildItem = function () {
        this._cancelPendingOpen();
        this._cancelPendingClose();
        this.activeIndex = this.items.indexOf(this._childItem);
    };
    /**
     * Open the menu item's submenu using the node for location.
     *
     * If the given item is already open, this is a no-op.
     *
     * Any pending open operation will be canceled before opening the
     * menu or queuing the delayed task to open the menu.
     */
    Menu.prototype._openChildMenu = function (item, node, delayed) {
        var _this = this;
        if (item === this._childItem) {
            return;
        }
        this._cancelPendingOpen();
        if (delayed) {
            this._openTimerId = setTimeout(function () {
                var menu = item.submenu;
                _this._openTimerId = 0;
                _this._childItem = item;
                _this._childMenu = menu;
                menu._parentMenu = _this;
                MenuPrivate.openSubmenu(menu, node);
            }, OPEN_DELAY);
        }
        else {
            var menu = item.submenu;
            this._childItem = item;
            this._childMenu = menu;
            menu._parentMenu = this;
            MenuPrivate.openSubmenu(menu, node);
        }
    };
    /**
     * Close the currently open child menu using a delayed task.
     *
     * If a task is pending or if there is no child menu, this is a no-op.
     */
    Menu.prototype._closeChildMenu = function () {
        var _this = this;
        if (this._closeTimerId || !this._childMenu) {
            return;
        }
        this._closeTimerId = setTimeout(function () {
            _this._closeTimerId = 0;
            var childMenu = _this._childMenu;
            if (childMenu) {
                _this._childMenu = null;
                _this._childItem = null;
                childMenu._parentMenu = null;
                childMenu.close();
            }
        }, CLOSE_DELAY);
    };
    /**
     * Cancel any pending child menu open task.
     */
    Menu.prototype._cancelPendingOpen = function () {
        if (this._openTimerId) {
            clearTimeout(this._openTimerId);
            this._openTimerId = 0;
        }
    };
    /**
     * Cancel any pending child menu close task.
     */
    Menu.prototype._cancelPendingClose = function () {
        if (this._closeTimerId) {
            clearTimeout(this._closeTimerId);
            this._closeTimerId = 0;
        }
    };
    return Menu;
})(base_1.AbstractMenu);
exports.Menu = Menu;
/**
 * The namespace for the menu private data.
 */
var MenuPrivate;
(function (MenuPrivate) {
    /**
     * A signal emitted when the menu is closed.
     */
    MenuPrivate.closedSignal = new phosphor_signaling_1.Signal();
    /**
     * Create the class name for a menu item.
     */
    function createItemClass(item) {
        var name = ITEM_CLASS;
        if (item.className) {
            name += ' ' + item.className;
        }
        if (item.type === menuitem_1.MenuItem.Separator) {
            return name + ' ' + SEPARATOR_TYPE_CLASS;
        }
        if (item.type === menuitem_1.MenuItem.Submenu) {
            name += ' ' + SUBMENU_TYPE_CLASS;
            if (item.disabled || !item.submenu) {
                name += ' ' + DISABLED_CLASS;
            }
            return name;
        }
        if (item.type === menuitem_1.MenuItem.Check) {
            name += ' ' + CHECK_TYPE_CLASS;
            if (item.checked) {
                name += ' ' + CHECKED_CLASS;
            }
        }
        if (item.disabled || !item.handler) {
            name += ' ' + DISABLED_CLASS;
        }
        return name;
    }
    MenuPrivate.createItemClass = createItemClass;
    /**
     * Hide the irrelevant item nodes for a menu bar.
     */
    function hideUselessItems(nodes, items) {
        // Hide the leading separators.
        var k1;
        for (k1 = 0; k1 < items.length; ++k1) {
            if (items[k1].type !== menuitem_1.MenuItem.Separator) {
                break;
            }
            nodes[k1].classList.add(HIDDEN_CLASS);
        }
        // Hide the trailing separators.
        var k2;
        for (k2 = items.length - 1; k2 >= 0; --k2) {
            if (items[k2].type !== menuitem_1.MenuItem.Separator) {
                break;
            }
            nodes[k2].classList.add(HIDDEN_CLASS);
        }
        // Hide the remaining consecutive separators.
        var hide = false;
        while (++k1 < k2) {
            if (items[k1].type !== menuitem_1.MenuItem.Separator) {
                hide = false;
            }
            else if (hide) {
                nodes[k1].classList.add(HIDDEN_CLASS);
            }
            else {
                hide = true;
            }
        }
    }
    MenuPrivate.hideUselessItems = hideUselessItems;
    /**
     * Open the menu as a root menu at the target location.
     */
    function openRootMenu(menu, x, y, forceX, forceY) {
        phosphor_messaging_1.sendMessage(menu, phosphor_widget_1.Widget.MsgUpdateRequest);
        var rect = clientViewportRect();
        var size = mountAndMeasure(menu, rect.height - (forceY ? y : 0));
        if (!forceX && (x + size.width > rect.x + rect.width)) {
            x = rect.x + rect.width - size.width;
        }
        if (!forceY && (y + size.height > rect.y + rect.height)) {
            if (y > rect.y + rect.height) {
                y = rect.y + rect.height - size.height;
            }
            else {
                y = y - size.height;
            }
        }
        showMenu(menu, x, y);
    }
    MenuPrivate.openRootMenu = openRootMenu;
    /**
     * Open a the menu as a submenu using the item node for positioning.
     */
    function openSubmenu(menu, item) {
        phosphor_messaging_1.sendMessage(menu, phosphor_widget_1.Widget.MsgUpdateRequest);
        var rect = clientViewportRect();
        var size = mountAndMeasure(menu, rect.height);
        var box = phosphor_domutil_1.boxSizing(menu.node);
        var itemRect = item.getBoundingClientRect();
        var x = itemRect.right - SUBMENU_OVERLAP;
        var y = itemRect.top - box.borderTop - box.paddingTop;
        if (x + size.width > rect.x + rect.width) {
            x = itemRect.left + SUBMENU_OVERLAP - size.width;
        }
        if (y + size.height > rect.y + rect.height) {
            y = itemRect.bottom + box.borderBottom + box.paddingBottom - size.height;
        }
        showMenu(menu, x, y);
    }
    MenuPrivate.openSubmenu = openSubmenu;
    /**
     * Get the currently visible viewport rect in page coordinates.
     */
    function clientViewportRect() {
        var elem = document.documentElement;
        var x = window.pageXOffset;
        var y = window.pageYOffset;
        var width = elem.clientWidth;
        var height = elem.clientHeight;
        return { x: x, y: y, width: width, height: height };
    }
    /**
     * Mount the menu as hidden and compute its optimal size.
     *
     * If the vertical scrollbar becomes visible, the menu will be expanded
     * by the scrollbar width to prevent clipping the contents of the menu.
     */
    function mountAndMeasure(menu, maxHeight) {
        var node = menu.node;
        var style = node.style;
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
        style.visibility = 'hidden';
        style.maxHeight = maxHeight + "px";
        menu.attach(document.body);
        if (node.scrollHeight > maxHeight) {
            style.width = (2 * node.offsetWidth - node.clientWidth) + "px";
        }
        var rect = node.getBoundingClientRect();
        return { width: rect.width, height: rect.height };
    }
    /**
     * Show the menu at the specified position.
     */
    function showMenu(menu, x, y) {
        var style = menu.node.style;
        style.top = Math.max(0, y) + "px";
        style.left = Math.max(0, x) + "px";
        style.visibility = '';
    }
})(MenuPrivate || (MenuPrivate = {}));
