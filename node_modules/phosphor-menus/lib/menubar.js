/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_domutil_1 = require('phosphor-domutil');
var base_1 = require('./base');
var menuitem_1 = require('./menuitem');
/**
 * The class name added to a menu bar widget.
 */
var MENU_BAR_CLASS = 'p-MenuBar';
/**
 * The class name added to a menu bar content node.
 */
var CONTENT_CLASS = 'p-MenuBar-content';
/**
 * The class name added to an open menu bar menu.
 */
var MENU_CLASS = 'p-MenuBar-menu';
/**
 * The class name added to a menu bar item node.
 */
var ITEM_CLASS = 'p-MenuBar-item';
/**
 * The class name added to a menu bar item icon cell.
 */
var ICON_CLASS = 'p-MenuBar-itemIcon';
/**
 * The class name added to a menu bar item text cell.
 */
var TEXT_CLASS = 'p-MenuBar-itemText';
/**
 * The class name added to a separator menu bar item.
 */
var SEPARATOR_TYPE_CLASS = 'p-type-separator';
/**
 * The class name added to an active menu bar and item.
 */
var ACTIVE_CLASS = 'p-mod-active';
/**
 * The class name added to a disabled menu bar item.
 */
var DISABLED_CLASS = 'p-mod-disabled';
/**
 * The class name added to a hidden menu bar item.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * A widget which displays menu items as a menu bar.
 */
var MenuBar = (function (_super) {
    __extends(MenuBar, _super);
    /**
     * Construct a new menu bar.
     *
     * @param items - The menu items to initialize the menu bar.
     *
     * #### Notes
     * Subclasses should not pass menu items to `super`. The subclass
     * should set its own items after it has been fully initialized.
     */
    function MenuBar(items) {
        _super.call(this);
        this._active = false;
        this._childMenu = null;
        this._nodes = [];
        this.addClass(MENU_BAR_CLASS);
        if (items)
            this.items = items;
    }
    /**
     * Create the DOM node for a menu bar.
     */
    MenuBar.createNode = function () {
        var node = document.createElement('div');
        var content = document.createElement('ul');
        content.className = CONTENT_CLASS;
        node.appendChild(content);
        return node;
    };
    /**
     * Create a new item node for a menu bar.
     *
     * @returns A new DOM node to use as an item in a menu bar.
     *
     * #### Notes
     * This method may be reimplemented to create custom items.
     */
    MenuBar.createItemNode = function () {
        var node = document.createElement('li');
        var icon = document.createElement('span');
        var text = document.createElement('span');
        node.className = ITEM_CLASS;
        icon.className = ICON_CLASS;
        text.className = TEXT_CLASS;
        node.appendChild(icon);
        node.appendChild(text);
        return node;
    };
    /**
     * Update an item node to reflect the current state of a menu item.
     *
     * @param node - A node created by a call to [[createItemNode]].
     *
     * @param item - The menu item to use for the item state.
     *
     * #### Notes
     * This is called automatically when the item should be updated.
     *
     * If the [[createItemNode]] method is reimplemented, this method
     * should also be reimplemented so that the item state is properly
     * updated.
     */
    MenuBar.updateItemNode = function (node, item) {
        var sep = item.type === menuitem_1.MenuItem.Separator;
        var icon = node.firstChild;
        var text = node.lastChild;
        node.className = MenuBarPrivate.createItemClass(item);
        icon.className = ICON_CLASS + (item.icon ? ' ' + item.icon : '');
        text.textContent = sep ? '' : item.text.replace(/&/g, '');
    };
    /**
     * Dispose of the resources held by the menu bar.
     */
    MenuBar.prototype.dispose = function () {
        this._reset();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(MenuBar.prototype, "childMenu", {
        /**
         * Get the child menu of the menu bar.
         *
         * #### Notes
         * This will be `null` if the menu bar does not have an open menu.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._childMenu;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuBar.prototype, "contentNode", {
        /**
         * Get the menu bar content node.
         *
         * #### Notes
         * This is the node which holds the menu item nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the submenu of the active item, if possible.
     *
     * #### Notes
     * This is a no-op if the menu bar is not visible, if there is no
     * active item, or if the active item is disabled or has no submenu.
     */
    MenuBar.prototype.openActiveItem = function () {
        if (!this.isVisible) {
            return;
        }
        var index = this.activeIndex;
        if (index === -1) {
            return;
        }
        var item = this.items[index];
        if (item.disabled || !item.submenu) {
            return;
        }
        this._activate();
        this._closeChildMenu();
        this._openChildMenu(item.submenu, this._nodes[index]);
    };
    /**
     * Handle the DOM events for the menu bar.
     *
     * @param event - The DOM event sent to the menu bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the menu bar's DOM nodes. It
     * should not be called directly by user code.
     */
    MenuBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseleave':
                this._evtMouseLeave(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'keypress':
                this._evtKeyPress(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A method invoked to test whether an item is selectable.
     *
     * @param item - The menu item of interest.
     *
     * @returns `true` if the item is selectable, `false` otherwise.
     */
    MenuBar.prototype.isSelectable = function (item) {
        return !item.disabled && !!item.submenu;
    };
    /**
     * A method invoked when the menu items change.
     *
     * @param oldItems - The old menu items.
     *
     * @param newItems - The new menu items.
     */
    MenuBar.prototype.onItemsChanged = function (oldItems, newItems) {
        // Reset the menu bar before updating the items.
        this._reset();
        // Disconnect the old item signals.
        for (var _i = 0; _i < oldItems.length; _i++) {
            var item = oldItems[_i];
            if (newItems.indexOf(item) === -1) {
                item.changed.disconnect(this._onItemChanged, this);
            }
        }
        // Connect the new item signals.
        for (var _a = 0; _a < newItems.length; _a++) {
            var item = newItems[_a];
            if (oldItems.indexOf(item) === -1) {
                item.changed.connect(this._onItemChanged, this);
            }
        }
        // Fetch common variables.
        var nodes = this._nodes;
        var content = this.contentNode;
        var constructor = this.constructor;
        // Remove any excess item nodes.
        while (nodes.length > newItems.length) {
            var node = nodes.pop();
            content.removeChild(node);
        }
        // Add any missing item nodes.
        while (nodes.length < newItems.length) {
            var node = constructor.createItemNode();
            content.appendChild(node);
            nodes.push(node);
        }
        // Schedule an update of the item nodes.
        this.update();
    };
    /**
     * A method invoked when the active index changes.
     *
     * @param oldIndex - The old active index.
     *
     * @param newIndex - The new active index.
     */
    MenuBar.prototype.onActiveIndexChanged = function (oldIndex, newIndex) {
        var oldNode = this._nodes[oldIndex];
        var newNode = this._nodes[newIndex];
        if (oldNode)
            oldNode.classList.remove(ACTIVE_CLASS);
        if (newNode)
            newNode.classList.add(ACTIVE_CLASS);
    };
    /**
     * A handler invoked on an `'update-request'` message.
     */
    MenuBar.prototype.onUpdateRequest = function (msg) {
        // Fetch common variables.
        var items = this.items;
        var nodes = this._nodes;
        var constructor = this.constructor;
        // Update the state of the item nodes.
        for (var i = 0, n = items.length; i < n; ++i) {
            constructor.updateItemNode(nodes[i], items[i]);
        }
        // Restore the active node class.
        var active = nodes[this.activeIndex];
        if (active)
            active.classList.add(ACTIVE_CLASS);
        // Hide the redundant and useless menu item nodes.
        MenuBarPrivate.hideUselessItems(nodes, items);
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    MenuBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('mousedown', this);
        this.node.addEventListener('mousemove', this);
        this.node.addEventListener('mouseleave', this);
        this.node.addEventListener('contextmenu', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    MenuBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('mousedown', this);
        this.node.removeEventListener('mousemove', this);
        this.node.removeEventListener('mouseleave', this);
        this.node.removeEventListener('contextmenu', this);
        this._reset();
    };
    /**
     * Handle the `'mousedown'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseDown = function (event) {
        // If the bar is active and the mouse press is on an open menu,
        // let that menu handle the press. The bar will reset when the
        // menu emits its `closed` signal.
        var x = event.clientX;
        var y = event.clientY;
        if (this._active && MenuBarPrivate.hitTestMenus(this._childMenu, x, y)) {
            return;
        }
        // Stop the propagation if the click was on the menu bar. This
        // prevents duplicate notification when the document mousedown
        // listener is also installed.
        if (phosphor_domutil_1.hitTest(this.node, x, y)) {
            event.preventDefault();
            event.stopPropagation();
        }
        // Check if the mouse was pressed on one of the menu items.
        var i = arrays.findIndex(this._nodes, function (node) { return phosphor_domutil_1.hitTest(node, x, y); });
        // If the press was not on an item, reset the menu bar.
        if (i === -1) {
            this._deactivate();
            this._closeChildMenu();
            this.activeIndex = -1;
            return;
        }
        // If the press was not the left mouse button, do nothing further.
        if (event.button !== 0) {
            return;
        }
        // If the bar is active, deactivate it and close the child menu.
        if (this._active) {
            this._deactivate();
            this._closeChildMenu();
            this.activeIndex = i;
            return;
        }
        // Otherwise, activate the bar and open the item if possible.
        this._activate();
        this.activeIndex = i;
        this.openActiveItem();
    };
    /**
     * Handle the `'mousemove'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseMove = function (event) {
        // Check if the mouse is over one of the menu items.
        var x = event.clientX;
        var y = event.clientY;
        var i = arrays.findIndex(this._nodes, function (node) { return phosphor_domutil_1.hitTest(node, x, y); });
        // Bail early if the active index will not change.
        if (i === this.activeIndex) {
            return;
        }
        // Bail early if the bar is active and the mouse is not over an
        // item. This allows the leading and trailing menus to be kept
        // open when the mouse is over the empty part of the menu bar.
        if (i === -1 && this._active) {
            return;
        }
        // Update the active index to the hovered item.
        this.activeIndex = i;
        // If the bar is not active, there's nothing more to do.
        if (!this._active) {
            return;
        }
        // Otherwise, close the current child menu and open the new one.
        this._closeChildMenu();
        this.openActiveItem();
    };
    /**
     * Handle the `'mouseleave'` event for the menu bar.
     */
    MenuBar.prototype._evtMouseLeave = function (event) {
        if (!this._active)
            this.activeIndex = -1;
    };
    /**
     * Handle the `'keydown'` event for the menu bar.
     */
    MenuBar.prototype._evtKeyDown = function (event) {
        event.stopPropagation();
        var menu = this._childMenu;
        var leaf = menu && menu.leafMenu;
        switch (event.keyCode) {
            case 13:
                event.preventDefault();
                if (leaf)
                    leaf.triggerActiveItem();
                break;
            case 27:
                event.preventDefault();
                if (leaf)
                    leaf.close();
                break;
            case 37:
                event.preventDefault();
                if (leaf && leaf !== menu) {
                    leaf.close();
                }
                else {
                    this._closeChildMenu();
                    this.activatePreviousItem();
                    this.openActiveItem();
                }
                break;
            case 38:
                event.preventDefault();
                if (leaf)
                    leaf.activatePreviousItem();
                break;
            case 39:
                event.preventDefault();
                if (leaf && leaf.activeItem && leaf.activeItem.submenu) {
                    leaf.openActiveItem();
                }
                else {
                    this._closeChildMenu();
                    this.activateNextItem();
                    this.openActiveItem();
                }
                break;
            case 40:
                event.preventDefault();
                if (leaf)
                    leaf.activateNextItem();
                break;
        }
    };
    /**
     * Handle the `'keypress'` event for the menu bar.
     */
    MenuBar.prototype._evtKeyPress = function (event) {
        event.preventDefault();
        event.stopPropagation();
        var menu = this._childMenu;
        var leaf = menu && menu.leafMenu;
        var key = String.fromCharCode(event.charCode);
        (leaf || this).activateMnemonicItem(key);
    };
    /**
     * Activate the menu bar and install the document listeners.
     */
    MenuBar.prototype._activate = function () {
        if (this._active) {
            return;
        }
        this._active = true;
        this.addClass(ACTIVE_CLASS);
        document.addEventListener('mousedown', this, true);
        document.addEventListener('keydown', this, true);
        document.addEventListener('keypress', this, true);
    };
    /**
     * Deactivate the menu bar and remove the document listeners.
     */
    MenuBar.prototype._deactivate = function () {
        if (!this._active) {
            return;
        }
        this._active = false;
        this.removeClass(ACTIVE_CLASS);
        document.removeEventListener('mousedown', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keypress', this, true);
    };
    /**
     * Open the child menu using the given item node for location.
     */
    MenuBar.prototype._openChildMenu = function (menu, node) {
        var rect = node.getBoundingClientRect();
        this._childMenu = menu;
        menu.addClass(MENU_CLASS);
        menu.open(rect.left, rect.bottom, false, true);
        menu.closed.connect(this._onMenuClosed, this);
    };
    /**
     * Close the current child menu, if one exists.
     */
    MenuBar.prototype._closeChildMenu = function () {
        var menu = this._childMenu;
        if (!menu) {
            return;
        }
        this._childMenu = null;
        menu.closed.disconnect(this._onMenuClosed, this);
        menu.removeClass(MENU_CLASS);
        menu.close();
    };
    /**
     * Reset the menu bar to its default state.
     */
    MenuBar.prototype._reset = function () {
        this._deactivate();
        this._closeChildMenu();
        this.activeIndex = -1;
    };
    /**
     * Handle the `changed` signal from a menu item.
     */
    MenuBar.prototype._onItemChanged = function () {
        this._reset();
        this.update();
    };
    /**
     * Handle the `closed` signal from the child menu.
     */
    MenuBar.prototype._onMenuClosed = function (sender) {
        sender.closed.disconnect(this._onMenuClosed, this);
        sender.removeClass(MENU_CLASS);
        this._deactivate();
        this._childMenu = null;
        this.activeIndex = -1;
    };
    return MenuBar;
})(base_1.AbstractMenu);
exports.MenuBar = MenuBar;
/**
 * The namespace for the menu bar private data.
 */
var MenuBarPrivate;
(function (MenuBarPrivate) {
    /**
     * Create the class name for a menu bar item.
     */
    function createItemClass(item) {
        var name = ITEM_CLASS;
        if (item.className) {
            name += ' ' + item.className;
        }
        if (item.type === menuitem_1.MenuItem.Separator) {
            return name + ' ' + SEPARATOR_TYPE_CLASS;
        }
        if (item.disabled || (item.type === menuitem_1.MenuItem.Submenu && !item.submenu)) {
            return name + ' ' + DISABLED_CLASS;
        }
        return name;
    }
    MenuBarPrivate.createItemClass = createItemClass;
    /**
     * Hit test the chain of menus for the given client position.
     */
    function hitTestMenus(menu, x, y) {
        while (menu) {
            if (phosphor_domutil_1.hitTest(menu.node, x, y)) {
                return true;
            }
            menu = menu.childMenu;
        }
        return false;
    }
    MenuBarPrivate.hitTestMenus = hitTestMenus;
    /**
     * Hide the irrelevant item nodes for a menu bar.
     */
    function hideUselessItems(nodes, items) {
        // Hide the leading non-submenu items.
        var k1;
        for (k1 = 0; k1 < items.length; ++k1) {
            if (items[k1].type === menuitem_1.MenuItem.Submenu) {
                break;
            }
            nodes[k1].classList.add(HIDDEN_CLASS);
        }
        // Hide the trailing separator items.
        var k2;
        for (k2 = items.length - 1; k2 >= 0; --k2) {
            if (items[k2].type === menuitem_1.MenuItem.Submenu) {
                break;
            }
            nodes[k2].classList.add(HIDDEN_CLASS);
        }
        // Hide the consecutive separators and other non-submenu items.
        var hide = false;
        while (++k1 < k2) {
            if (items[k1].type === menuitem_1.MenuItem.Submenu) {
                hide = false;
            }
            else if (items[k1].type !== menuitem_1.MenuItem.Separator) {
                nodes[k1].classList.add(HIDDEN_CLASS);
            }
            else if (hide) {
                nodes[k1].classList.add(HIDDEN_CLASS);
            }
            else {
                hide = true;
            }
        }
    }
    MenuBarPrivate.hideUselessItems = hideUselessItems;
})(MenuBarPrivate || (MenuBarPrivate = {}));
