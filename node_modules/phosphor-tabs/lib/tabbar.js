/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
/**
 * The class name added to TabBar instances.
 */
var TAB_BAR_CLASS = 'p-TabBar';
/**
 * The class name added to a tab bar body node.
 */
var BODY_CLASS = 'p-TabBar-body';
/**
 * The class name added to a tab bar header node.
 */
var HEADER_CLASS = 'p-TabBar-header';
/**
 * The class name added to a tab bar content node.
 */
var CONTENT_CLASS = 'p-TabBar-content';
/**
 * The class name added to a tab bar footer node.
 */
var FOOTER_CLASS = 'p-TabBar-footer';
/**
 * The class name added to a tab bar tab.
 */
var TAB_CLASS = 'p-TabBar-tab';
/**
 * The class name added to a tab text node.
 */
var TEXT_CLASS = 'p-TabBar-tabText';
/**
 * The class name added to a tab icon node.
 */
var ICON_CLASS = 'p-TabBar-tabIcon';
/**
 * The class name added to a tab close icon node.
 */
var CLOSE_CLASS = 'p-TabBar-tabCloseIcon';
/**
 * The class name added to a tab bar and tab when dragging.
 */
var DRAGGING_CLASS = 'p-mod-dragging';
/**
 * The class name added to the current tab.
 */
var CURRENT_CLASS = 'p-mod-current';
/**
 * The class name added to a closable tab.
 */
var CLOSABLE_CLASS = 'p-mod-closable';
/**
 * The start drag distance threshold.
 */
var DRAG_THRESHOLD = 5;
/**
 * The detach distance threshold.
 */
var DETACH_THRESHOLD = 20;
/**
 * The tab transition duration.
 */
var TRANSITION_DURATION = 150; // Keep in sync with CSS.
/**
 * A widget which displays tab items as a row of tabs.
 */
var TabBar = (function (_super) {
    __extends(TabBar, _super);
    /**
     * Construct a new tab bar.
     */
    function TabBar() {
        _super.call(this);
        this._tabsMovable = false;
        this._items = [];
        this._tabs = [];
        this._dirtySet = new Set();
        this._currentItem = null;
        this._dragData = null;
        this.addClass(TAB_BAR_CLASS);
    }
    /**
     * Create the DOM node for a tab bar.
     */
    TabBar.createNode = function () {
        var node = document.createElement('div');
        var header = document.createElement('div');
        var body = document.createElement('div');
        var footer = document.createElement('div');
        var content = document.createElement('ul');
        header.className = HEADER_CLASS;
        body.className = BODY_CLASS;
        footer.className = FOOTER_CLASS;
        content.className = CONTENT_CLASS;
        body.appendChild(content);
        node.appendChild(header);
        node.appendChild(body);
        node.appendChild(footer);
        return node;
    };
    /**
     * Create and initialize a tab node for a tab bar.
     *
     * @param title - The title to use for the initial tab state.
     *
     * @returns A new DOM node to use as a tab in a tab bar.
     *
     * #### Notes
     * It is not necessary to subscribe to the `changed` signal of the
     * title. The tab bar subscribes to that signal and will call the
     * [[updateTab]] static method automatically as needed.
     *
     * This method may be reimplemented to create custom tabs.
     */
    TabBar.createTab = function (title) {
        var node = document.createElement('li');
        var icon = document.createElement('span');
        var text = document.createElement('span');
        var close = document.createElement('span');
        node.className = TAB_CLASS;
        icon.className = ICON_CLASS;
        text.className = TEXT_CLASS;
        close.className = CLOSE_CLASS;
        node.appendChild(icon);
        node.appendChild(text);
        node.appendChild(close);
        this.updateTab(node, title);
        return node;
    };
    /**
     * Update a tab node to reflect the current state of a title.
     *
     * @param tab - A tab node created by a call to [[createTab]].
     *
     * @param title - The title object to use for the tab state.
     *
     * #### Notes
     * This is called automatically when the title state changes.
     *
     * If the [[createTab]] method is reimplemented, this method should
     * also be reimplemented so that the tab state is properly updated.
     */
    TabBar.updateTab = function (tab, title) {
        var tabInfix = title.className ? ' ' + title.className : '';
        var tabSuffix = title.closable ? ' ' + CLOSABLE_CLASS : '';
        var iconSuffix = title.icon ? ' ' + title.icon : '';
        var icon = tab.firstChild;
        var text = icon.nextSibling;
        tab.className = TAB_CLASS + tabInfix + tabSuffix;
        icon.className = ICON_CLASS + iconSuffix;
        text.textContent = title.text;
    };
    /**
     * Get the close icon node for a given tab node.
     *
     * @param tab - A tab node created by a call to [[createTab]].
     *
     * @returns The close icon node for the tab node.
     *
     * #### Notes
     * The close icon node is used to correctly process click events.
     *
     * If the [[createTab]] method is reimplemented, this method should
     * also be reimplemented so that the correct icon node is returned.
     */
    TabBar.tabCloseIcon = function (tab) {
        return tab.lastChild;
    };
    /**
     * Dispose of the resources held by the widget.
     */
    TabBar.prototype.dispose = function () {
        this._releaseMouse();
        this._tabs.length = 0;
        this._items.length = 0;
        this._dirtySet.clear();
        this._currentItem = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabBar.prototype, "currentChanged", {
        /**
         * A signal emitted when the current tab is changed.
         */
        get: function () {
            return TabBarPrivate.currentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabMoved", {
        /**
         * A signal emitted when a tab is moved by the user.
         */
        get: function () {
            return TabBarPrivate.tabMovedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabCloseRequested", {
        /**
         * A signal emitted when the user clicks a tab's close icon.
         */
        get: function () {
            return TabBarPrivate.tabCloseRequestedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabDetachRequested", {
        /**
         * A signal emitted when a tab is dragged beyond the detach threshold.
         */
        get: function () {
            return TabBarPrivate.tabDetachRequestedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentItem", {
        /**
         * Get the currently selected tab item.
         */
        get: function () {
            return this._currentItem;
        },
        /**
         * Set the currently selected tab item.
         */
        set: function (value) {
            var item = value || null;
            if (this._currentItem === item) {
                return;
            }
            var index = item ? this._items.indexOf(item) : -1;
            if (item && index === -1) {
                console.warn('Tab item not contained in tab bar.');
                return;
            }
            this._currentItem = item;
            this.currentChanged.emit({ index: index, item: item });
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         */
        get: function () {
            return this._tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         */
        set: function (value) {
            this._tabsMovable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "headerNode", {
        /**
         * Get the tab bar header node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar header.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(HEADER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "bodyNode", {
        /**
         * Get the tab bar body node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(BODY_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "footerNode", {
        /**
         * Get the tab bar footer node.
         *
         * #### Notes
         * This node can be used to add extra content to the tab bar footer.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(FOOTER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "contentNode", {
        /**
         * Get the tab bar content node.
         *
         * #### Notes
         * This is the node which holds the tab nodes.
         *
         * Modifying this node directly can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the number of tab items in the tab bar.
     *
     * @returns The number of tab items in the tab bar.
     */
    TabBar.prototype.itemCount = function () {
        return this._items.length;
    };
    /**
     * Get the tab item at the specified index.
     *
     * @param index - The index of the tab item of interest.
     *
     * @returns The tab item at the specified index, or `undefined`.
     */
    TabBar.prototype.itemAt = function (index) {
        return this._items[index];
    };
    /**
     * Get the index of the specified tab item.
     *
     * @param item - The tab item of interest.
     *
     * @returns The index of the specified item, or `-1`.
     */
    TabBar.prototype.itemIndex = function (item) {
        return this._items.indexOf(item);
    };
    /**
     * Add a tab item to the end of the tab bar.
     *
     * @param item - The tab item to add to the tab bar.
     *
     * #### Notes
     * If the item is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.addItem = function (item) {
        this.insertItem(this.itemCount(), item);
    };
    /**
     * Insert a tab item at the specified index.
     *
     * @param index - The index at which to insert the item.
     *
     * @param item - The tab item to insert into the tab bar.
     *
     * #### Notes
     * If the item is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.insertItem = function (index, item) {
        this._releaseMouse();
        var n = this._items.length;
        var i = this._items.indexOf(item);
        var j = Math.max(0, Math.min(index | 0, n));
        if (i !== -1) {
            if (j === n)
                j--;
            if (i === j)
                return;
            arrays.move(this._tabs, i, j);
            arrays.move(this._items, i, j);
            this.contentNode.insertBefore(this._tabs[j], this._tabs[j + 1]);
        }
        else {
            var tab = this.constructor.createTab(item.title);
            arrays.insert(this._tabs, j, tab);
            arrays.insert(this._items, j, item);
            this.contentNode.insertBefore(tab, this._tabs[j + 1]);
            item.title.changed.connect(this._onTitleChanged, this);
            if (!this.currentItem)
                this.currentItem = item;
        }
        this.update();
    };
    /**
     * Remove a tab item from the tab bar.
     *
     * @param item - The tab item to remove from the tab bar.
     *
     * #### Notes
     * If the item is not in the tab bar, this is a no-op.
     */
    TabBar.prototype.removeItem = function (item) {
        this._releaseMouse();
        var i = arrays.remove(this._items, item);
        if (i === -1) {
            return;
        }
        this._dirtySet.delete(item.title);
        item.title.changed.disconnect(this._onTitleChanged, this);
        this.contentNode.removeChild(arrays.removeAt(this._tabs, i));
        if (this.currentItem === item) {
            var next = this._items[i];
            var prev = this._items[i - 1];
            this.currentItem = next || prev;
        }
        this.update();
    };
    /**
     * Get the tab node for the item at the given index.
     *
     * @param index - The index of the tab item of interest.
     *
     * @returns The tab node for the item, or `undefined`.
     */
    TabBar.prototype.tabAt = function (index) {
        return this._tabs[index];
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     *
     * #### Notes
     * This will cause the tab bar to stop handling mouse events and to
     * restore the tabs to their non-dragged positions.
     */
    TabBar.prototype.releaseMouse = function () {
        this._releaseMouse();
    };
    /**
     * Handle the DOM events for the tab bar.
     *
     * @param event - The DOM event sent to the tab bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the tab bar's DOM node. It should
     * not be called directly by user code.
     */
    TabBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    TabBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    TabBar.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
        this._releaseMouse();
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    TabBar.prototype.onUpdateRequest = function (msg) {
        var tabs = this._tabs;
        var items = this._items;
        var dirty = this._dirtySet;
        var current = this._currentItem;
        var constructor = this.constructor;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var tab = tabs[i];
            var item = items[i];
            if (dirty.has(item.title)) {
                constructor.updateTab(tab, item.title);
            }
            if (item === current) {
                tab.classList.add(CURRENT_CLASS);
                tab.style.zIndex = "" + n;
            }
            else {
                tab.classList.remove(CURRENT_CLASS);
                tab.style.zIndex = "" + (n - i - 1);
            }
        }
        dirty.clear();
    };
    /**
     * Handle the `'keydown'` event for the tab bar.
     */
    TabBar.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27)
            this._releaseMouse();
    };
    /**
     * Handle the `'click'` event for the tab bar.
     */
    TabBar.prototype._evtClick = function (event) {
        // Do nothing if it's not a left click.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the click is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = arrays.findIndex(this._tabs, function (tab) { return phosphor_domutil_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Clicking on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the click if the title is not closable.
        var item = this._items[i];
        if (!item.title.closable) {
            return;
        }
        // Ignore the click if it was not on a close icon.
        var constructor = this.constructor;
        var icon = constructor.tabCloseIcon(this._tabs[i]);
        if (!icon.contains(event.target)) {
            return;
        }
        // Emit the tab close requested signal.
        this.tabCloseRequested.emit({ index: i, item: item });
    };
    /**
     * Handle the `'mousedown'` event for the tab bar.
     */
    TabBar.prototype._evtMouseDown = function (event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the press is not on a tab.
        var x = event.clientX;
        var y = event.clientY;
        var i = arrays.findIndex(this._tabs, function (tab) { return phosphor_domutil_1.hitTest(tab, x, y); });
        if (i < 0) {
            return;
        }
        // Pressing on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the press if it was on a close icon.
        var constructor = this.constructor;
        var icon = constructor.tabCloseIcon(this._tabs[i]);
        if (icon.contains(event.target)) {
            return;
        }
        // Setup the drag data if the tabs are movable.
        if (this._tabsMovable) {
            this._dragData = new TabBarPrivate.DragData();
            this._dragData.index = i;
            this._dragData.tab = this._tabs[i];
            this._dragData.pressX = event.clientX;
            this._dragData.pressY = event.clientY;
            document.addEventListener('mousemove', this, true);
            document.addEventListener('mouseup', this, true);
            document.addEventListener('keydown', this, true);
            document.addEventListener('contextmenu', this, true);
        }
        // Update the current item to the pressed item.
        this.currentItem = this._items[i];
    };
    /**
     * Handle the `'mousemove'` event for the tab bar.
     */
    TabBar.prototype._evtMouseMove = function (event) {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag.
        event.preventDefault();
        event.stopPropagation();
        // Ensure the drag threshold is exceeded before moving the tab.
        var data = this._dragData;
        if (!data.dragActive) {
            var dx = Math.abs(event.clientX - data.pressX);
            var dy = Math.abs(event.clientY - data.pressY);
            if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                return;
            }
            // Fill in the rest of the drag data measurements.
            var tabRect = data.tab.getBoundingClientRect();
            data.tabLeft = data.tab.offsetLeft;
            data.tabWidth = tabRect.width;
            data.tabPressX = data.pressX - tabRect.left;
            data.tabLayout = TabBarPrivate.snapTabLayout(this._tabs);
            data.contentRect = this.contentNode.getBoundingClientRect();
            data.override = phosphor_domutil_1.overrideCursor('default');
            // Add the dragging classes and mark the drag as active.
            data.tab.classList.add(DRAGGING_CLASS);
            this.addClass(DRAGGING_CLASS);
            data.dragActive = true;
        }
        // Emit the detach request signal if the threshold is exceeded.
        if (!data.detachRequested && TabBarPrivate.detachExceeded(data, event)) {
            data.detachRequested = true;
            var index = data.index;
            var item = this._items[index];
            var clientX = event.clientX;
            var clientY = event.clientY;
            this.tabDetachRequested.emit({ index: index, item: item, clientX: clientX, clientY: clientY });
            if (data.dragAborted) {
                return;
            }
        }
        // Update the tab layout and computed target index.
        TabBarPrivate.layoutTabs(this._tabs, data, event);
    };
    /**
     * Handle the `'mouseup'` event for the tab bar.
     */
    TabBar.prototype._evtMouseUp = function (event) {
        var _this = this;
        // Do nothing if it's not a left mouse release.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Remove the extra mouse event listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Bail early if the drag is not active.
        var data = this._dragData;
        if (!data.dragActive) {
            this._dragData = null;
            return;
        }
        // Position the tab at its final resting position.
        TabBarPrivate.finalizeTabPosition(data);
        // Remove the dragging class from the tab so it can be transitioned.
        data.tab.classList.remove(DRAGGING_CLASS);
        // Complete the release on a timer to allow the tab to transition.
        setTimeout(function () {
            // Do nothing if the drag has been aborted.
            if (data.dragAborted) {
                return;
            }
            // Clear the drag data reference.
            _this._dragData = null;
            // Reset the positions of the tabs.
            TabBarPrivate.resetTabPositions(_this._tabs);
            // Clear the cursor grab and drag styles.
            data.override.dispose();
            _this.removeClass(DRAGGING_CLASS);
            // If the tab was not moved, there is nothing else to do.
            var i = data.index;
            var j = data.targetIndex;
            if (j === -1 || i === j) {
                return;
            }
            // Move the tab and related tab item to the new location.
            arrays.move(_this._tabs, i, j);
            arrays.move(_this._items, i, j);
            _this.contentNode.insertBefore(_this._tabs[j], _this._tabs[j + 1]);
            // Emit the tab moved signal and schedule a render update.
            _this.tabMoved.emit({ fromIndex: i, toIndex: j, item: _this._items[j] });
            _this.update();
        }, TRANSITION_DURATION);
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     */
    TabBar.prototype._releaseMouse = function () {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Remove the extra mouse listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Clear the drag data reference.
        var data = this._dragData;
        this._dragData = null;
        // Indicate the drag has been aborted. This allows the mouse
        // event handlers to return early when the drag is canceled.
        data.dragAborted = true;
        // If the drag is not active, there's nothing more to do.
        if (!data.dragActive) {
            return;
        }
        // Reset the tabs to their non-dragged positions.
        TabBarPrivate.resetTabPositions(this._tabs);
        // Clear the cursor override and extra styling classes.
        data.override.dispose();
        data.tab.classList.remove(DRAGGING_CLASS);
        this.removeClass(DRAGGING_CLASS);
    };
    /**
     * Handle the `changed` signal of a title object.
     */
    TabBar.prototype._onTitleChanged = function (sender) {
        this._dirtySet.add(sender);
        this.update();
    };
    return TabBar;
})(phosphor_widget_1.Widget);
exports.TabBar = TabBar;
/**
 * The namespace for the `TabBar` class private data.
 */
var TabBarPrivate;
(function (TabBarPrivate) {
    /**
     * A signal emitted when the current tab item is changed.
     */
    TabBarPrivate.currentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a tab is moved by the user.
     */
    TabBarPrivate.tabMovedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the user clicks a tab's close icon.
     */
    TabBarPrivate.tabCloseRequestedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a tab is dragged beyond the detach threshold.
     */
    TabBarPrivate.tabDetachRequestedSignal = new phosphor_signaling_1.Signal();
    /**
     * A struct which holds the drag data for a tab bar.
     */
    var DragData = (function () {
        function DragData() {
            /**
             * The tab node being dragged.
             */
            this.tab = null;
            /**
             * The index of the tab being dragged.
             */
            this.index = -1;
            /**
             * The offset left of the tab being dragged.
             */
            this.tabLeft = -1;
            /**
             * The offset width of the tab being dragged.
             */
            this.tabWidth = -1;
            /**
             * The original mouse X position in tab coordinates.
             */
            this.tabPressX = -1;
            /**
             * The tab target index upon mouse release.
             */
            this.targetIndex = -1;
            /**
             * The array of tab layout objects snapped at drag start.
             */
            this.tabLayout = null;
            /**
             * The mouse press client X position.
             */
            this.pressX = -1;
            /**
             * The mouse press client Y position.
             */
            this.pressY = -1;
            /**
             * The bounding client rect of the tab bar content node.
             */
            this.contentRect = null;
            /**
             * The disposable to clean up the cursor override.
             */
            this.override = null;
            /**
             * Whether the drag is currently active.
             */
            this.dragActive = false;
            /**
             * Whether the drag has been aborted.
             */
            this.dragAborted = false;
            /**
             * Whether a detach request as been made.
             */
            this.detachRequested = false;
        }
        return DragData;
    })();
    TabBarPrivate.DragData = DragData;
    /**
     * Get a snapshot of the current tab layout values.
     */
    function snapTabLayout(tabs) {
        var layout = new Array(tabs.length);
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var node = tabs[i];
            var left = node.offsetLeft;
            var width = node.offsetWidth;
            var cstyle = window.getComputedStyle(node);
            var margin = parseInt(cstyle.marginLeft, 10) || 0;
            layout[i] = { margin: margin, left: left, width: width };
        }
        return layout;
    }
    TabBarPrivate.snapTabLayout = snapTabLayout;
    /**
     * Test if the event exceeds the drag detach threshold.
     */
    function detachExceeded(data, event) {
        var rect = data.contentRect;
        return ((event.clientX < rect.left - DETACH_THRESHOLD) ||
            (event.clientX >= rect.right + DETACH_THRESHOLD) ||
            (event.clientY < rect.top - DETACH_THRESHOLD) ||
            (event.clientY >= rect.bottom + DETACH_THRESHOLD));
    }
    TabBarPrivate.detachExceeded = detachExceeded;
    /**
     * Update the relative tab positions and computed target index.
     */
    function layoutTabs(tabs, data, event) {
        var targetIndex = data.index;
        var targetLeft = event.clientX - data.contentRect.left - data.tabPressX;
        var targetRight = targetLeft + data.tabWidth;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var style = tabs[i].style;
            var layout = data.tabLayout[i];
            var threshold = layout.left + (layout.width >> 1);
            if (i < data.index && targetLeft < threshold) {
                style.left = data.tabWidth + data.tabLayout[i + 1].margin + 'px';
                targetIndex = Math.min(targetIndex, i);
            }
            else if (i > data.index && targetRight > threshold) {
                style.left = -data.tabWidth - layout.margin + 'px';
                targetIndex = Math.max(targetIndex, i);
            }
            else if (i === data.index) {
                var ideal = event.clientX - data.pressX;
                var limit = data.contentRect.width - (data.tabLeft + data.tabWidth);
                style.left = Math.max(-data.tabLeft, Math.min(ideal, limit)) + 'px';
            }
            else {
                style.left = '';
            }
        }
        data.targetIndex = targetIndex;
    }
    TabBarPrivate.layoutTabs = layoutTabs;
    /**
     * Position the drag tab at its final resting relative position.
     */
    function finalizeTabPosition(data) {
        var ideal;
        if (data.targetIndex === data.index) {
            ideal = 0;
        }
        else if (data.targetIndex > data.index) {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.left + tgt.width - data.tabWidth - data.tabLeft;
        }
        else {
            var tgt = data.tabLayout[data.targetIndex];
            ideal = tgt.left - data.tabLeft;
        }
        var style = data.tab.style;
        var limit = data.contentRect.width - (data.tabLeft + data.tabWidth);
        style.left = Math.max(-data.tabLeft, Math.min(ideal, limit)) + 'px';
    }
    TabBarPrivate.finalizeTabPosition = finalizeTabPosition;
    /**
     * Reset the relative positions of the given tabs.
     */
    function resetTabPositions(tabs) {
        for (var i = 0, n = tabs.length; i < n; ++i) {
            tabs[i].style.left = '';
        }
    }
    TabBarPrivate.resetTabPositions = resetTabPositions;
})(TabBarPrivate || (TabBarPrivate = {}));
