// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var utils = require('jupyter-js-utils');
var phosphor_signaling_1 = require('phosphor-signaling');
/**
 * An implementation of a document context.
 */
var Context = (function () {
    /**
     * Construct a new document context.
     */
    function Context(manager) {
        this._id = '';
        this._manager = null;
        this._manager = manager;
        this._id = utils.uuid();
    }
    Object.defineProperty(Context.prototype, "kernelChanged", {
        /**
         * A signal emitted when the kernel changes.
         */
        get: function () {
            return Private.kernelChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "pathChanged", {
        /**
         * A signal emitted when the path changes.
         */
        get: function () {
            return Private.pathChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "dirtyCleared", {
        /**
         * A signal emitted when the model is saved or reverted.
         */
        get: function () {
            return Private.dirtyClearedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "id", {
        /**
         * The unique id of the context.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "model", {
        /**
         * Get the model associated with the document.
         *
         * #### Notes
         * This is a read-only property
         */
        get: function () {
            return this._manager.getModel(this._id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "kernel", {
        /**
         * The current kernel associated with the document.
         *
         * #### Notes
         * This is a read-only propery.
         */
        get: function () {
            return this._manager.getKernel(this._id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "path", {
        /**
         * The current path associated with the document.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._manager.getPath(this._id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "contentsModel", {
        /**
         * The current contents model associated with the document
         *
         * #### Notes
         * This is a read-only property.  The model will have an
         * empty `contents` field.
         */
        get: function () {
            return this._manager.getContentsModel(this._id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "kernelspecs", {
        /**
         * Get the kernel spec information.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._manager.getKernelspecs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Context.prototype, "isDisposed", {
        /**
         * Get whether the context has been disposed.
         */
        get: function () {
            return this._manager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the context.
     */
    Context.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._manager = null;
        this._id = '';
    };
    /**
     * Change the current kernel associated with the document.
     */
    Context.prototype.changeKernel = function (options) {
        return this._manager.changeKernel(this._id, options);
    };
    /**
     * Save the document contents to disk.
     */
    Context.prototype.save = function () {
        return this._manager.save(this._id);
    };
    /**
     * Save the document to a different path.
     */
    Context.prototype.saveAs = function (path) {
        return this._manager.saveAs(this._id, path);
    };
    /**
     * Revert the document contents to disk contents.
     */
    Context.prototype.revert = function () {
        return this._manager.revert(this._id);
    };
    /**
     * Get the list of running sessions.
     */
    Context.prototype.listSessions = function () {
        return this._manager.listSessions();
    };
    /**
     * Add a sibling widget to the document manager.
     *
     * @param widget - The widget to add to the document manager.
     *
     * @returns A disposable used to remove the sibling if desired.
     *
     * #### Notes
     * It is assumed that the widget has the same model and context
     * as the original widget.
     */
    Context.prototype.addSibling = function (widget) {
        return this._manager.addSibling(this._id, widget);
    };
    return Context;
}());
/**
 * An object which manages the active contexts.
 */
var ContextManager = (function () {
    /**
     * Construct a new context manager.
     */
    function ContextManager(contentsManager, sessionManager, kernelspecs, opener) {
        this._contentsManager = null;
        this._sessionManager = null;
        this._kernelspecids = null;
        this._contexts = Object.create(null);
        this._opener = null;
        this._contentsManager = contentsManager;
        this._sessionManager = sessionManager;
        this._opener = opener;
        this._kernelspecids = kernelspecs;
    }
    Object.defineProperty(ContextManager.prototype, "isDisposed", {
        /**
         * Get whether the context manager has been disposed.
         */
        get: function () {
            return this._contentsManager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the document manager.
     */
    ContextManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this._contentsManager = null;
        this._sessionManager = null;
        this._kernelspecids = null;
        for (var id in this._contexts) {
            var contextEx = this._contexts[id];
            contextEx.context.dispose();
            contextEx.model.dispose();
            var session = contextEx.session;
            if (session) {
                session.dispose();
            }
        }
        this._contexts = null;
        this._opener = null;
    };
    /**
     * Create a new context.
     */
    ContextManager.prototype.createNew = function (path, model, factory) {
        var context = new Context(this);
        var id = context.id;
        this._contexts[id] = {
            context: context,
            path: path,
            model: model,
            modelName: factory.name,
            opts: factory.contentsOptions,
            contentsModel: null,
            session: null
        };
        return id;
    };
    /**
     * Get a context for a given path and model name.
     */
    ContextManager.prototype.findContext = function (path, modelName) {
        for (var id in this._contexts) {
            var contextEx = this._contexts[id];
            if (contextEx.path === path && contextEx.modelName === modelName) {
                return id;
            }
        }
    };
    /**
     * Find a context by path.
     */
    ContextManager.prototype.getIdsForPath = function (path) {
        var ids = [];
        for (var id in this._contexts) {
            if (this._contexts[id].path === path) {
                ids.push(id);
            }
        }
        return ids;
    };
    /**
     * Get a context by id.
     */
    ContextManager.prototype.getContext = function (id) {
        return this._contexts[id].context;
    };
    /**
     * Get the model associated with a context.
     */
    ContextManager.prototype.getModel = function (id) {
        return this._contexts[id].model;
    };
    /**
     * Remove a context.
     */
    ContextManager.prototype.removeContext = function (id) {
        var contextEx = this._contexts[id];
        contextEx.model.dispose();
        contextEx.context.dispose();
        delete this._contexts[id];
    };
    /**
     * Get the current kernel associated with a document.
     */
    ContextManager.prototype.getKernel = function (id) {
        var session = this._contexts[id].session;
        return session ? session.kernel : null;
    };
    /**
     * Get the current path associated with a document.
     */
    ContextManager.prototype.getPath = function (id) {
        return this._contexts[id].path;
    };
    /**
     * Get the current contents model associated with a document.
     */
    ContextManager.prototype.getContentsModel = function (id) {
        return this._contexts[id].contentsModel;
    };
    /**
     * Change the current kernel associated with the document.
     *
     * @param options - If given, change the kernel (starting a session
     * if necessary). If falsey, shut down any existing session and return
     * a void promise.
     */
    ContextManager.prototype.changeKernel = function (id, options) {
        var contextEx = this._contexts[id];
        var session = contextEx.session;
        if (options) {
            if (session) {
                return session.changeKernel(options);
            }
            else {
                var path = contextEx.path;
                var sOptions = {
                    notebookPath: path,
                    kernelName: options.name,
                    kernelId: options.id
                };
                return this._startSession(id, sOptions);
            }
        }
        else {
            if (session) {
                return session.shutdown().then(function () {
                    session.dispose();
                    contextEx.session = null;
                    return void 0;
                });
            }
            else {
                return Promise.resolve(void 0);
            }
        }
    };
    /**
     * Update the path of an open document.
     *
     * @param id - The id of the context.
     *
     * @param newPath - The new path.
     */
    ContextManager.prototype.rename = function (oldPath, newPath) {
        // Update all of the paths, but only update one session
        // so there is only one REST API call.
        var ids = this.getIdsForPath(oldPath);
        var sessionUpdated = false;
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            var contextEx = this._contexts[id];
            contextEx.path = newPath;
            contextEx.context.pathChanged.emit(newPath);
            if (!sessionUpdated) {
                var session = contextEx.session;
                if (session) {
                    session.renameNotebook(newPath);
                    sessionUpdated = true;
                }
            }
        }
    };
    /**
     * Get the current kernelspec information.
     */
    ContextManager.prototype.getKernelspecs = function () {
        return this._kernelspecids;
    };
    /**
     * Save the document contents to disk.
     */
    ContextManager.prototype.save = function (id) {
        var _this = this;
        var contextEx = this._contexts[id];
        var opts = utils.copy(contextEx.opts);
        var path = contextEx.path;
        var model = contextEx.model;
        if (model.readOnly) {
            return Promise.reject(new Error('Read only'));
        }
        if (opts.type === 'notebook' || opts.format === 'json') {
            opts.content = model.toJSON();
        }
        else {
            opts.content = model.toString();
        }
        return this._contentsManager.save(path, opts).then(function (contents) {
            contextEx.contentsModel = _this._copyContentsModel(contents);
            model.dirty = false;
        });
    };
    /**
     * Save a document to a new file name.
     *
     * This results in a new session.
     */
    ContextManager.prototype.saveAs = function (id, newPath) {
        var _this = this;
        var contextEx = this._contexts[id];
        contextEx.path = newPath;
        contextEx.context.pathChanged.emit(newPath);
        if (contextEx.session) {
            var options = {
                notebook: { path: newPath },
                kernel: { id: contextEx.session.id }
            };
            return this._startSession(id, options).then(function () {
                return _this.save(id);
            });
        }
        return this.save(id);
    };
    /**
     * Revert the contents of a path.
     */
    ContextManager.prototype.revert = function (id) {
        var _this = this;
        var contextEx = this._contexts[id];
        var opts = contextEx.opts;
        var path = contextEx.path;
        var model = contextEx.model;
        return this._contentsManager.get(path, opts).then(function (contents) {
            if (contents.format === 'json') {
                model.fromJSON(contents.content);
            }
            else {
                model.fromString(contents.content);
            }
            contextEx.contentsModel = _this._copyContentsModel(contents);
            model.dirty = false;
        });
    };
    /**
     * Get the list of running sessions.
     */
    ContextManager.prototype.listSessions = function () {
        return this._sessionManager.listRunning();
    };
    /**
     * Add a sibling widget to the document manager.
     */
    ContextManager.prototype.addSibling = function (id, widget) {
        var opener = this._opener;
        return opener(id, widget);
    };
    /**
     * Start a session and set up its signals.
     */
    ContextManager.prototype._startSession = function (id, options) {
        var contextEx = this._contexts[id];
        var context = contextEx.context;
        return this._sessionManager.startNew(options).then(function (session) {
            if (contextEx.session) {
                contextEx.session.dispose();
            }
            contextEx.session = session;
            context.kernelChanged.emit(session.kernel);
            session.notebookPathChanged.connect(function (s, path) {
                if (path !== contextEx.path) {
                    contextEx.path = path;
                    context.pathChanged.emit(path);
                }
            });
            session.kernelChanged.connect(function (s, kernel) {
                context.kernelChanged.emit(kernel);
            });
            return session.kernel;
        });
    };
    /**
     * Copy the contents of a contents model, without the content.
     */
    ContextManager.prototype._copyContentsModel = function (model) {
        return {
            path: model.path,
            name: model.name,
            type: model.type,
            writable: model.writable,
            created: model.created,
            last_modified: model.last_modified,
            mimetype: model.mimetype,
            format: model.format
        };
    };
    return ContextManager;
}());
exports.ContextManager = ContextManager;
/**
 * A namespace for private data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when the kernel changes.
     */
    Private.kernelChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the path changes.
     */
    Private.pathChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the model is saved or reverted.
     */
    Private.dirtyClearedSignal = new phosphor_signaling_1.Signal();
})(Private || (Private = {}));
