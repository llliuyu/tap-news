// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_disposable_1 = require('phosphor-disposable');
var phosphor_panel_1 = require('phosphor-panel');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
var dialog_1 = require('../dialog');
var context_1 = require('./context');
/**
 * The class name added to a document container widgets.
 */
var DOCUMENT_CLASS = 'jp-DocumentWidget';
/**
 * The document manager.
 *
 * #### Notes
 * The document manager is used to register model and widget creators,
 * and the file browser uses the document manager to create widgets. The
 * document manager maintains a context for each path and model type that is
 * open, and a list of widgets for each context. The document manager is in
 * control of the proper closing and disposal of the widgets and contexts.
 */
var DocumentManager = (function () {
    /**
     * Construct a new document manager.
     */
    function DocumentManager(registry, contentsManager, sessionManager, kernelspecs, opener) {
        var _this = this;
        this._widgets = Object.create(null);
        this._contentsManager = null;
        this._sessionManager = null;
        this._contextManager = null;
        this._specs = null;
        this._registry = null;
        this._registry = registry;
        this._contentsManager = contentsManager;
        this._sessionManager = sessionManager;
        this._specs = kernelspecs;
        this._contextManager = new context_1.ContextManager(contentsManager, sessionManager, kernelspecs, function (id, widget) {
            var parent = _this._createWidget('', id);
            parent.setContent(widget);
            opener.open(parent);
            return new phosphor_disposable_1.DisposableDelegate(function () {
                parent.close();
            });
        });
    }
    Object.defineProperty(DocumentManager.prototype, "kernelspecs", {
        /**
         * Get the kernel spec ids for the manager.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._specs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "registry", {
        /**
         * Get the registry used by the manager.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._registry;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentManager.prototype, "isDisposed", {
        /**
         * Get whether the document manager has been disposed.
         */
        get: function () {
            return this._contentsManager === null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the document manager.
     */
    DocumentManager.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        for (var id in this._widgets) {
            for (var _i = 0, _a = this._widgets[id]; _i < _a.length; _i++) {
                var widget = _a[_i];
                widget.dispose();
            }
        }
        this._widgets = null;
        this._contentsManager = null;
        this._sessionManager = null;
        this._contextManager.dispose();
        this._contextManager = null;
    };
    /**
     * Open a file and return the widget used to display the contents.
     *
     * @param path - The file path to open.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - An optional kernel name/id to override the default.
     */
    DocumentManager.prototype.open = function (path, widgetName, kernel) {
        var _this = this;
        if (widgetName === void 0) { widgetName = 'default'; }
        var registry = this._registry;
        if (widgetName === 'default') {
            var parts = path.split('.');
            var ext = void 0;
            if (parts.length === 1 || (parts[0] === '' && parts.length === 2)) {
                ext = '';
            }
            else {
                ext = '.' + parts.pop().toLowerCase();
            }
            widgetName = registry.listWidgetFactories(ext)[0];
        }
        var mFactory = registry.getModelFactory(widgetName);
        if (!mFactory) {
            return;
        }
        var widget;
        // Use an existing context if available.
        var id = this._contextManager.findContext(path, mFactory.name);
        if (id) {
            widget = this._createWidget(widgetName, id);
            this._populateWidget(widget, kernel);
            return widget;
        }
        var lang = mFactory.preferredLanguage(path);
        var model = mFactory.createNew(lang);
        id = this._contextManager.createNew(path, model, mFactory);
        widget = this._createWidget(widgetName, id);
        // Load the contents from disk.
        this._contextManager.revert(id).then(function () {
            _this._populateWidget(widget, kernel);
        });
        return widget;
    };
    /**
     * Create a new file of the given name.
     *
     * @param path - The file path to use.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - An optional kernel name/id to override the default.
     */
    DocumentManager.prototype.createNew = function (path, widgetName, kernel) {
        var _this = this;
        if (widgetName === void 0) { widgetName = 'default'; }
        var registry = this._registry;
        if (widgetName === 'default') {
            var parts = path.split('.');
            var ext = void 0;
            if (parts.length === 1 || (parts[0] === '' && parts.length === 2)) {
                ext = '';
            }
            else {
                ext = '.' + parts.pop().toLowerCase();
            }
            widgetName = registry.listWidgetFactories(ext)[0];
        }
        var mFactory = registry.getModelFactory(widgetName);
        if (!mFactory) {
            return;
        }
        var lang = mFactory.preferredLanguage(path);
        var model = mFactory.createNew(lang);
        var id = this._contextManager.createNew(path, model, mFactory);
        var widget = this._createWidget(widgetName, id);
        // Save the contents to disk to get a valid contentsModel for the
        // context.
        this._contextManager.save(id).then(function () {
            _this._populateWidget(widget, kernel);
        });
        return widget;
    };
    /**
     * List the running notebook sessions.
     */
    DocumentManager.prototype.listSessions = function () {
        return this._sessionManager.listRunning();
    };
    /**
     * Handle the renaming of an open document.
     *
     * @param oldPath - The previous path.
     *
     * @param newPath - The new path.
     */
    DocumentManager.prototype.handleRename = function (oldPath, newPath) {
        this._contextManager.rename(oldPath, newPath);
    };
    /**
     * Handle a file deletion.
     */
    DocumentManager.prototype.handleDelete = function (path) {
        // TODO: Leave all of the widgets open and flag them as orphaned?
    };
    /**
     * See if a widget already exists for the given path and widget name.
     *
     * #### Notes
     * This can be used to use an existing widget instead of opening
     * a new widget.
     */
    DocumentManager.prototype.findWidget = function (path, widgetName) {
        if (widgetName === void 0) { widgetName = 'default'; }
        var ids = this._contextManager.getIdsForPath(path);
        if (widgetName === 'default') {
            widgetName = this._registry.defaultWidgetFactory;
        }
        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
            var id = ids_1[_i];
            for (var _a = 0, _b = this._widgets[id]; _a < _b.length; _a++) {
                var widget = _b[_a];
                if (widget.name === widgetName) {
                    return widget;
                }
            }
        }
    };
    /**
     * Clone a widget.
     *
     * #### Notes
     * This will create a new widget with the same model and context
     * as this widget.
     */
    DocumentManager.prototype.clone = function (widget) {
        var parent = this._createWidget(widget.name, widget.context.id);
        this._populateWidget(parent);
        return parent;
    };
    /**
     * Close the widgets associated with a given path.
     */
    DocumentManager.prototype.closeFile = function (path) {
        var ids = this._contextManager.getIdsForPath(path);
        for (var _i = 0, ids_2 = ids; _i < ids_2.length; _i++) {
            var id = ids_2[_i];
            var widgets = this._widgets[id] || [];
            for (var _a = 0, widgets_1 = widgets; _a < widgets_1.length; _a++) {
                var w = widgets_1[_a];
                w.close();
            }
        }
    };
    /**
     * Close all of the open documents.
     */
    DocumentManager.prototype.closeAll = function () {
        for (var id in this._widgets) {
            for (var _i = 0, _a = this._widgets[id]; _i < _a.length; _i++) {
                var w = _a[_i];
                w.close();
            }
        }
    };
    /**
     * Create a container widget and handle its lifecycle.
     */
    DocumentManager.prototype._createWidget = function (name, id) {
        var factory = this._registry.getWidgetFactory(name);
        var widget = new DocumentWidget(name, id, this._contextManager, factory, this._widgets);
        if (!(id in this._widgets)) {
            this._widgets[id] = [];
        }
        this._widgets[id].push(widget);
        return widget;
    };
    /**
     * Create a content widget and add it to the container widget.
     */
    DocumentManager.prototype._populateWidget = function (parent, kernel) {
        var factory = this._registry.getWidgetFactory(parent.name);
        var id = parent.context.id;
        var model = this._contextManager.getModel(id);
        model.initialize();
        var context = this._contextManager.getContext(id);
        var child = factory.createNew(model, context, kernel);
        parent.setContent(child);
        // Handle widget extensions.
        var disposables = new phosphor_disposable_1.DisposableSet();
        for (var _i = 0, _a = this._registry.getWidgetExtensions(parent.name); _i < _a.length; _i++) {
            var extender = _a[_i];
            disposables.add(extender.createNew(child, model, context));
        }
        parent.disposed.connect(function () {
            disposables.dispose();
        });
    };
    return DocumentManager;
}());
exports.DocumentManager = DocumentManager;
/**
 * A container widget for documents.
 */
var DocumentWidget = (function (_super) {
    __extends(DocumentWidget, _super);
    /**
     * Construct a new document widget.
     */
    function DocumentWidget(name, id, manager, factory, widgets) {
        _super.call(this);
        this._manager = null;
        this._factory = null;
        this._id = '';
        this._name = '';
        this._widgets = null;
        this.addClass(DOCUMENT_CLASS);
        this.layout = new phosphor_panel_1.PanelLayout();
        this._name = name;
        this._id = id;
        this._manager = manager;
        this._widgets = widgets;
        this._factory = factory;
        this.title.closable = true;
    }
    Object.defineProperty(DocumentWidget.prototype, "populated", {
        /**
         * A signal emitted when the document widget is populated.
         */
        get: function () {
            return Private.populatedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentWidget.prototype, "name", {
        /**
         * Get the name of the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentWidget.prototype, "context", {
        /**
         * The context for the widget.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._manager.getContext(this._id);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentWidget.prototype, "content", {
        /**
         * The content widget used by the document widget.
         */
        get: function () {
            var layout = this.layout;
            return layout.childAt(0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Dispose of the resources held by the widget.
     */
    DocumentWidget.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        // Remove the widget from the widget registry.
        var id = this._id;
        var index = this._widgets[id].indexOf(this);
        this._widgets[id].splice(index, 1);
        // Dispose of the context if this is the last widget using it.
        if (!this._widgets[id].length) {
            this._manager.removeContext(id);
        }
        this._manager = null;
        this._factory = null;
        this._widgets = null;
        _super.prototype.dispose.call(this);
    };
    /**
     * Set the child the widget.
     *
     * #### Notes
     * This function is not intended to be called by user code.
     */
    DocumentWidget.prototype.setContent = function (child) {
        var _this = this;
        var layout = this.layout;
        if (layout.childAt(0)) {
            throw new Error('Content already set');
        }
        this.title.text = child.title.text;
        this.title.icon = child.title.icon;
        this.title.className = child.title.className;
        // Mirror this title based on the child.
        child.title.changed.connect(function () {
            _this.title.text = child.title.text;
            _this.title.icon = child.title.icon;
            _this.title.className = child.title.className;
        });
        // Add the child widget to the layout.
        this.layout.addChild(child);
        this.populated.emit(child);
    };
    /**
     * Handle `'close-request'` messages.
     */
    DocumentWidget.prototype.onCloseRequest = function (msg) {
        var _this = this;
        var model = this._manager.getModel(this._id);
        var layout = this.layout;
        var child = layout.childAt(0);
        // Handle dirty state.
        this._maybeClose(model.dirty).then(function (result) {
            if (result) {
                // Let the widget factory handle closing.
                return _this._factory.beforeClose(model, _this.context, child);
            }
            return result;
        }).then(function (result) {
            if (result) {
                // Perform close tasks.
                return _this._actuallyClose();
            }
            return result;
        }).then(function (result) {
            if (result) {
                // Dispose of document widgets when they are closed.
                _this.dispose();
            }
        }).catch(function () {
            _this.dispose();
        });
    };
    /**
     * Ask the user whether to close an unsaved file.
     */
    DocumentWidget.prototype._maybeClose = function (dirty) {
        // Bail if the model is not dirty or other widgets are using the model.
        var widgets = this._widgets[this._id];
        if (!dirty || widgets.length > 1) {
            return Promise.resolve(true);
        }
        return dialog_1.showDialog({
            title: 'Close without saving?',
            body: "File \"" + this.title.text + "\" has unsaved changes, close without saving?",
            host: this.node
        }).then(function (value) {
            if (value && value.text === 'OK') {
                return true;
            }
            return false;
        });
    };
    /**
     * Perform closing tasks for the widget.
     */
    DocumentWidget.prototype._actuallyClose = function () {
        var _this = this;
        // Check for a dangling kernel.
        var widgets = this._widgets[this._id];
        var kernelId = this.context.kernel ? this.context.kernel.id : '';
        if (!kernelId || widgets.length > 1) {
            return Promise.resolve(true);
        }
        for (var id in this._widgets) {
            for (var _i = 0, _a = this._widgets[id]; _i < _a.length; _i++) {
                var widget = _a[_i];
                var kId = widget.context.kernel || widget.context.kernel.id;
                if (widget !== this && kId === kernelId) {
                    return Promise.resolve(true);
                }
            }
        }
        return dialog_1.showDialog({
            title: 'Shut down kernel?',
            body: "Shut down " + this.context.kernel.name + "?",
            host: this.node
        }).then(function (value) {
            if (value && value.text === 'OK') {
                return _this.context.kernel.shutdown();
            }
        }).then(function () {
            return true;
        });
    };
    return DocumentWidget;
}(phosphor_widget_1.Widget));
exports.DocumentWidget = DocumentWidget;
/**
 * A private namespace for DocumentManager data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when the document widget is populated.
     */
    Private.populatedSignal = new phosphor_signaling_1.Signal();
})(Private || (Private = {}));
