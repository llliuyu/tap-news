import { IKernelId, IContentsManager, INotebookSessionManager, IKernelSpecIds, ISessionId } from 'jupyter-js-services';
import { IDisposable } from 'phosphor-disposable';
import { Message } from 'phosphor-messaging';
import { ISignal } from 'phosphor-signaling';
import { Widget } from 'phosphor-widget';
import { IWidgetOpener } from '../filebrowser/browser';
import { ContextManager } from './context';
import { IDocumentContext, IWidgetFactory } from './interfaces';
import { DocumentRegistry } from './registry';
/**
 * The document manager.
 *
 * #### Notes
 * The document manager is used to register model and widget creators,
 * and the file browser uses the document manager to create widgets. The
 * document manager maintains a context for each path and model type that is
 * open, and a list of widgets for each context. The document manager is in
 * control of the proper closing and disposal of the widgets and contexts.
 */
export declare class DocumentManager implements IDisposable {
    /**
     * Construct a new document manager.
     */
    constructor(registry: DocumentRegistry, contentsManager: IContentsManager, sessionManager: INotebookSessionManager, kernelspecs: IKernelSpecIds, opener: IWidgetOpener);
    /**
     * Get the kernel spec ids for the manager.
     *
     * #### Notes
     * This is a read-only property.
     */
    kernelspecs: IKernelSpecIds;
    /**
     * Get the registry used by the manager.
     *
     * #### Notes
     * This is a read-only property.
     */
    registry: DocumentRegistry;
    /**
     * Get whether the document manager has been disposed.
     */
    isDisposed: boolean;
    /**
     * Dispose of the resources held by the document manager.
     */
    dispose(): void;
    /**
     * Open a file and return the widget used to display the contents.
     *
     * @param path - The file path to open.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - An optional kernel name/id to override the default.
     */
    open(path: string, widgetName?: string, kernel?: IKernelId): DocumentWidget;
    /**
     * Create a new file of the given name.
     *
     * @param path - The file path to use.
     *
     * @param widgetName - The name of the widget factory to use.
     *
     * @param kernel - An optional kernel name/id to override the default.
     */
    createNew(path: string, widgetName?: string, kernel?: IKernelId): DocumentWidget;
    /**
     * List the running notebook sessions.
     */
    listSessions(): Promise<ISessionId[]>;
    /**
     * Handle the renaming of an open document.
     *
     * @param oldPath - The previous path.
     *
     * @param newPath - The new path.
     */
    handleRename(oldPath: string, newPath: string): void;
    /**
     * Handle a file deletion.
     */
    handleDelete(path: string): void;
    /**
     * See if a widget already exists for the given path and widget name.
     *
     * #### Notes
     * This can be used to use an existing widget instead of opening
     * a new widget.
     */
    findWidget(path: string, widgetName?: string): DocumentWidget;
    /**
     * Clone a widget.
     *
     * #### Notes
     * This will create a new widget with the same model and context
     * as this widget.
     */
    clone(widget: DocumentWidget): DocumentWidget;
    /**
     * Close the widgets associated with a given path.
     */
    closeFile(path: string): void;
    /**
     * Close all of the open documents.
     */
    closeAll(): void;
    /**
     * Create a container widget and handle its lifecycle.
     */
    private _createWidget(name, id);
    /**
     * Create a content widget and add it to the container widget.
     */
    private _populateWidget(parent, kernel?);
    private _widgets;
    private _contentsManager;
    private _sessionManager;
    private _contextManager;
    private _specs;
    private _registry;
}
/**
 * A container widget for documents.
 */
export declare class DocumentWidget extends Widget {
    /**
     * A signal emitted when the document widget is populated.
     */
    populated: ISignal<DocumentWidget, Widget>;
    /**
     * Construct a new document widget.
     */
    constructor(name: string, id: string, manager: ContextManager, factory: IWidgetFactory<Widget>, widgets: {
        [key: string]: DocumentWidget[];
    });
    /**
     * Get the name of the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    name: string;
    /**
     * The context for the widget.
     *
     * #### Notes
     * This is a read-only property.
     */
    context: IDocumentContext;
    /**
     * The content widget used by the document widget.
     */
    content: Widget;
    /**
     * Dispose of the resources held by the widget.
     */
    dispose(): void;
    /**
     * Set the child the widget.
     *
     * #### Notes
     * This function is not intended to be called by user code.
     */
    setContent(child: Widget): void;
    /**
     * Handle `'close-request'` messages.
     */
    protected onCloseRequest(msg: Message): void;
    /**
     * Ask the user whether to close an unsaved file.
     */
    private _maybeClose(dirty);
    /**
     * Perform closing tasks for the widget.
     */
    private _actuallyClose();
    private _manager;
    private _factory;
    private _id;
    private _name;
    private _widgets;
}
