// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_widget_1 = require('phosphor-widget');
var dialog_1 = require('../dialog');
var kernelselector_1 = require('../docmanager/kernelselector');
/**
 * The class name added for a file conflict.
 */
var FILE_CONFLICT_CLASS = 'jp-mod-conflict';
/**
 * Open a file using a dialog.
 */
function openWithDialog(path, manager, host) {
    var handler;
    return manager.listSessions().then(function (sessions) {
        handler = new OpenWithHandler(path, manager, sessions);
        return dialog_1.showDialog({
            title: 'Open File',
            host: host,
            body: handler.node,
            okText: 'OPEN'
        });
    }).then(function (result) {
        if (result.text === 'OPEN') {
            return handler.open();
        }
    });
}
exports.openWithDialog = openWithDialog;
/**
 * Create a new file using a dialog.
 */
function createNewDialog(model, manager, host) {
    var handler;
    return manager.listSessions().then(function (sessions) {
        handler = new CreateNewHandler(model, manager, sessions);
        return dialog_1.showDialog({
            title: 'Create New File',
            host: host,
            body: handler.node,
            okText: 'CREATE'
        });
    }).then(function (result) {
        if (result.text === 'CREATE') {
            return handler.open();
        }
    });
}
exports.createNewDialog = createNewDialog;
/**
 * A widget used to open files with a specific widget/kernel.
 */
var OpenWithHandler = (function (_super) {
    __extends(OpenWithHandler, _super);
    /**
     * Construct a new "open with" dialog.
     */
    function OpenWithHandler(path, manager, sessions, host) {
        _super.call(this);
        this._ext = '';
        this._manager = null;
        this._host = null;
        this._sessions = null;
        this._manager = manager;
        this._host = host;
        this._sessions = sessions;
        this.input.textContent = path;
        this._ext = path.split('.').pop();
        this.populateFactories();
        this.widgetDropdown.onchange = this.widgetChanged.bind(this);
    }
    /**
     * Create the node for an open with handler.
     */
    OpenWithHandler.createNode = function () {
        var body = document.createElement('div');
        var name = document.createElement('span');
        var widgetDropdown = document.createElement('select');
        var kernelDropdown = document.createElement('select');
        body.appendChild(name);
        body.appendChild(widgetDropdown);
        body.appendChild(kernelDropdown);
        return body;
    };
    /**
     * Dispose of the resources used by the widget.
     */
    OpenWithHandler.prototype.dispose = function () {
        this._host = null;
        this._manager = null;
        this._sessions = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(OpenWithHandler.prototype, "input", {
        /**
         * Get the input text node.
         */
        get: function () {
            return this.node.firstChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OpenWithHandler.prototype, "widgetDropdown", {
        /**
         * Get the widget dropdown node.
         */
        get: function () {
            return this.node.children[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OpenWithHandler.prototype, "kernelDropdown", {
        /**
         * Get the kernel dropdown node.
         */
        get: function () {
            return this.node.children[2];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the file and return the document widget.
     */
    OpenWithHandler.prototype.open = function () {
        var path = this.input.textContent;
        var widgetName = this.widgetDropdown.value;
        var kernelValue = this.kernelDropdown.value;
        var kernelId;
        if (kernelValue !== 'null') {
            kernelId = JSON.parse(kernelValue);
        }
        return this._manager.open(path, widgetName, kernelId);
    };
    /**
     * Populate the widget factories.
     */
    OpenWithHandler.prototype.populateFactories = function () {
        var factories = this._manager.registry.listWidgetFactories(this._ext);
        var widgetDropdown = this.widgetDropdown;
        for (var _i = 0, factories_1 = factories; _i < factories_1.length; _i++) {
            var factory = factories_1[_i];
            var option = document.createElement('option');
            option.text = factory;
            widgetDropdown.appendChild(option);
        }
        this.widgetChanged();
    };
    /**
     * Handle a change to the widget.
     */
    OpenWithHandler.prototype.widgetChanged = function () {
        var widgetName = this.widgetDropdown.value;
        var preference = this._manager.registry.getKernelPreference(this._ext, widgetName);
        updateKernels(preference, this.kernelDropdown, this._manager.kernelspecs, this._sessions);
    };
    return OpenWithHandler;
}(phosphor_widget_1.Widget));
/**
 * A widget used to create new files.
 */
var CreateNewHandler = (function (_super) {
    __extends(CreateNewHandler, _super);
    /**
     * Construct a new "create new" dialog.
     */
    function CreateNewHandler(model, manager, sessions) {
        var _this = this;
        _super.call(this);
        this._model = null;
        this._manager = null;
        this._sessions = null;
        this._sentinal = 'UNKNOWN_EXTENSION';
        this._prevExt = '';
        this._extensions = [];
        this._model = model;
        this._manager = manager;
        this._sessions = sessions;
        // Create a file name based on the current time.
        var time = new Date();
        time.setMinutes(time.getMinutes() - time.getTimezoneOffset());
        var name = time.toJSON().slice(0, 10);
        name += '-' + time.getHours() + time.getMinutes() + time.getSeconds();
        this.input.value = name + '.txt';
        // Check for name conflicts when the input changes.
        this.input.addEventListener('input', function () {
            _this.inputChanged();
        });
        // Update the widget choices when the file type changes.
        this.fileTypeDropdown.addEventListener('change', function () {
            _this.fileTypeChanged();
        });
        // Update the kernel choices when the widget changes.
        this.widgetDropdown.addEventListener('change', function () {
            _this.widgetDropdownChanged();
        });
        // Populate the lists of file types and widget factories.
        this.populateFileTypes();
        this.populateFactories();
    }
    /**
     * Create the node for a create new handler.
     */
    CreateNewHandler.createNode = function () {
        var body = document.createElement('div');
        var name = document.createElement('input');
        var fileTypeDropdown = document.createElement('select');
        var widgetDropdown = document.createElement('select');
        var kernelDropdown = document.createElement('select');
        body.appendChild(name);
        body.appendChild(fileTypeDropdown);
        body.appendChild(widgetDropdown);
        body.appendChild(kernelDropdown);
        return body;
    };
    /**
     * Dispose of the resources used by the widget.
     */
    CreateNewHandler.prototype.dispose = function () {
        this._model = null;
        this._sessions = null;
        this._manager = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(CreateNewHandler.prototype, "input", {
        /**
         * Get the input text node.
         */
        get: function () {
            return this.node.firstChild;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateNewHandler.prototype, "fileTypeDropdown", {
        /**
         * Get the file type dropdown node.
         */
        get: function () {
            return this.node.children[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateNewHandler.prototype, "widgetDropdown", {
        /**
         * Get the widget dropdown node.
         */
        get: function () {
            return this.node.children[2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateNewHandler.prototype, "kernelDropdown", {
        /**
         * Get the kernel dropdown node.
         */
        get: function () {
            return this.node.children[3];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CreateNewHandler.prototype, "ext", {
        /**
         * Get the current extension for the file.
         */
        get: function () {
            return this.input.value.split('.').pop();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Open the file and return the document widget.
     */
    CreateNewHandler.prototype.open = function () {
        var path = this.input.textContent;
        var widgetName = this.widgetDropdown.value;
        var kernelValue = this.kernelDropdown.value;
        var kernelId;
        if (kernelValue !== 'null') {
            kernelId = JSON.parse(kernelValue);
        }
        return this._manager.createNew(path, widgetName, kernelId);
    };
    /**
     * Handle a change to the input.
     */
    CreateNewHandler.prototype.inputChanged = function () {
        var path = this.input.value;
        for (var _i = 0, _a = this._model.sortedItems; _i < _a.length; _i++) {
            var item = _a[_i];
            if (item.path === path) {
                this.addClass(FILE_CONFLICT_CLASS);
                return;
            }
        }
        var ext = this.ext;
        if (ext === this._prevExt) {
            return;
        }
        // Update the file type dropdown and the factories.
        if (this._extensions.indexOf(ext) === -1) {
            this.fileTypeDropdown.value = this._sentinal;
        }
        else {
            this.fileTypeDropdown.value = ext;
        }
        this.populateFactories();
    };
    /**
     * Populate the file types.
     */
    CreateNewHandler.prototype.populateFileTypes = function () {
        var fileTypes = this._manager.registry.listFileTypes();
        var dropdown = this.fileTypeDropdown;
        var option = document.createElement('option');
        option.text = 'File';
        option.value = this._sentinal;
        for (var _i = 0, fileTypes_1 = fileTypes; _i < fileTypes_1.length; _i++) {
            var ft = fileTypes_1[_i];
            option = document.createElement('option');
            option.text = ft.name + " (" + ft.extension + ")";
            option.value = ft.extension;
            dropdown.appendChild(option);
            this._extensions.push(ft.extension);
        }
        if (this.ext in this._extensions) {
            dropdown.value = this.ext;
        }
        else {
            dropdown.value = this._sentinal;
        }
    };
    /**
     * Populate the widget factories.
     */
    CreateNewHandler.prototype.populateFactories = function () {
        var ext = this.ext;
        var factories = this._manager.registry.listWidgetFactories(ext);
        var widgetDropdown = this.widgetDropdown;
        for (var _i = 0, factories_2 = factories; _i < factories_2.length; _i++) {
            var factory = factories_2[_i];
            var option = document.createElement('option');
            option.text = factory;
            widgetDropdown.appendChild(option);
        }
        this.widgetDropdownChanged();
        this._prevExt = ext;
    };
    /**
     * Handle changes to the file type dropdown.
     */
    CreateNewHandler.prototype.fileTypeChanged = function () {
        // Update the current input.
        var oldExt = this.ext;
        var newExt = this.fileTypeDropdown.value;
        if (oldExt === newExt || newExt === '') {
            return;
        }
        var oldName = this.input.value;
        var base = oldName.slice(0, oldName.length - oldExt.length - 1);
        this.input.value = base + newExt;
    };
    /**
     * Handle a change to the widget dropdown.
     */
    CreateNewHandler.prototype.widgetDropdownChanged = function () {
        var ext = this.ext;
        var widgetName = this.widgetDropdown.value;
        var preference = this._manager.registry.getKernelPreference(ext, widgetName);
        updateKernels(preference, this.kernelDropdown, this._manager.kernelspecs, this._sessions);
    };
    return CreateNewHandler;
}(phosphor_widget_1.Widget));
/**
 * Update a kernel listing based on a kernel preference.
 */
function updateKernels(preference, node, specs, running) {
    if (!preference.canStartKernel) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
        node.disabled = true;
        return;
    }
    var lang = preference.language;
    node.disabled = false;
    kernelselector_1.populateKernels(node, specs, running, lang);
    // Select the "null" valued kernel if we do not prefer a kernel.
    if (!preference.preferKernel) {
        node.value = 'null';
    }
}
