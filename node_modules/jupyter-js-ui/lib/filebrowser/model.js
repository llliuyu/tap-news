// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var phosphor_signaling_1 = require('phosphor-signaling');
/**
 * An implementation of a file browser view model.
 *
 * #### Notes
 * All paths parameters without a leading `'/'` are interpreted as relative to
 * the current directory.  Supports `'../'` syntax.
 */
var FileBrowserModel = (function () {
    /**
     * Construct a new file browser view model.
     */
    function FileBrowserModel(contentsManager, sessionManager, specs) {
        this._maxUploadSizeMb = 15;
        this._contentsManager = null;
        this._sessionIds = [];
        this._sessionManager = null;
        this._selection = Object.create(null);
        this._sortKey = 'name';
        this._ascending = true;
        this._unsortedNames = [];
        this._specs = null;
        this._contentsManager = contentsManager;
        this._sessionManager = sessionManager;
        this._specs = specs;
        this._model = { path: '', name: '/', type: 'directory', content: [] };
        this.cd();
    }
    Object.defineProperty(FileBrowserModel.prototype, "refreshed", {
        /**
         * Get the refreshed signal.
         */
        get: function () {
            return Private.refreshedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "fileChanged", {
        /**
         * Get the file path changed signal.
         */
        get: function () {
            return Private.fileChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "path", {
        /**
         * Get the current path.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._model.path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "selectionChanged", {
        /**
         * Get the selection changed signal.
         */
        get: function () {
            return Private.selectionChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "isDisposed", {
        /**
         * Get whether the view model is disposed.
         */
        get: function () {
            return this._model === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "sessionIds", {
        /**
         * Get the session ids for active notebooks.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._sessionIds.slice();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "kernelspecs", {
        /**
         * Get the kernel specs.
         */
        get: function () {
            return this._specs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "sortAscending", {
        /**
         * Get whether the items are sorted in ascending order.
         */
        get: function () {
            return this._ascending;
        },
        /**
         * Set whether the items are sorted in ascending order.
         */
        set: function (value) {
            this._ascending = value;
            this._sort();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "sortKey", {
        /**
         * Get which key the items are sorted on.
         */
        get: function () {
            return this._sortKey;
        },
        /**
         * Set which key the items are sorted on.
         */
        set: function (value) {
            this._sortKey = value;
            this._sort();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileBrowserModel.prototype, "sortedItems", {
        /**
         * Get the sorted list of items.
         *
         * #### Notes
         * This is a read-only property and should be treated as immutable.
         */
        get: function () {
            return this._model.content;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Select an item by name.
     *
     * #### Notes
     * This is a no-op if the name is not valid or already selected.
     */
    FileBrowserModel.prototype.select = function (name) {
        if (!this._selection[name]) {
            this._selection[name] = true;
            this.selectionChanged.emit(void 0);
        }
    };
    /**
     * De-select an item by name.
     *
     * #### Notes
     * This is a no-op if the name is not valid or not selected.
     */
    FileBrowserModel.prototype.deselect = function (name) {
        if (this._selection[name]) {
            delete this._selection[name];
            this.selectionChanged.emit(void 0);
        }
    };
    /**
     * Check whether an item is selected.
     *
     * #### Notes
     * Returns `true` for a valid name that is selected, `false` otherwise.
     */
    FileBrowserModel.prototype.isSelected = function (name) {
        return !!this._selection[name];
    };
    /**
     * Get the list of selected names.
     */
    FileBrowserModel.prototype.getSelected = function () {
        return Object.keys(this._selection);
    };
    /**
     * Clear the selected items.
     */
    FileBrowserModel.prototype.clearSelected = function () {
        this._selection = Object.create(null);
        this.selectionChanged.emit(void 0);
    };
    /**
     * Dispose of the resources held by the view model.
     */
    FileBrowserModel.prototype.dispose = function () {
        this._model = null;
        this._contentsManager = null;
        this._selection = null;
        phosphor_signaling_1.clearSignalData(this);
    };
    /**
     * Change directory.
     *
     * @param path - The path to the file or directory.
     *
     * @returns A promise with the contents of the directory.
     */
    FileBrowserModel.prototype.cd = function (path) {
        var _this = this;
        if (path === void 0) { path = ''; }
        if (path !== '') {
            path = Private.normalizePath(this._model.path, path);
        }
        var previous = this._selection;
        if (path !== this.path) {
            previous = Object.create(null);
        }
        var selection = Object.create(null);
        return this._contentsManager.get(path, {}).then(function (contents) {
            _this._model = contents;
            var content = contents.content;
            var names = content.map(function (value, index) { return value.name; });
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (previous[name_1]) {
                    selection[name_1] = true;
                }
            }
            _this._unsortedNames = content.map(function (value, index) { return value.name; });
            if (_this._sortKey !== 'name' || !_this._ascending) {
                _this._sort();
            }
            return _this._findSessions();
        }).then(function () {
            _this.selectionChanged.emit(void 0);
            _this.refreshed.emit(void 0);
        });
    };
    /**
     * Refresh the current directory.
     */
    FileBrowserModel.prototype.refresh = function () {
        return this.cd('.').catch(function (error) {
            console.error(error);
            var msg = 'Unable to refresh the directory listing due to ';
            msg += 'lost server connection.';
            error.message = msg;
            throw error;
        });
    };
    /**
     * Copy a file.
     *
     * @param fromFile - The path of the original file.
     *
     * @param toDir - The path to the target directory.
     *
     * @returns A promise which resolves to the contents of the file.
     */
    FileBrowserModel.prototype.copy = function (fromFile, toDir) {
        var _this = this;
        var normalizePath = Private.normalizePath;
        fromFile = normalizePath(this._model.path, fromFile);
        toDir = normalizePath(this._model.path, toDir);
        return this._contentsManager.copy(fromFile, toDir).then(function (contents) {
            _this.fileChanged.emit({
                name: 'file',
                oldValue: void 0,
                newValue: contents.path
            });
            return contents;
        });
    };
    /**
     * Delete a file.
     *
     * @param: path - The path to the file to be deleted.
     *
     * @returns A promise which resolves when the file is deleted.
     */
    FileBrowserModel.prototype.delete = function (path) {
        var _this = this;
        var normalizePath = Private.normalizePath;
        path = normalizePath(this._model.path, path);
        return this._contentsManager.delete(path).then(function () {
            _this.fileChanged.emit({
                name: 'file',
                oldValue: path,
                newValue: void 0
            });
        });
    };
    /**
     * Download a file.
     *
     * @param - path - The path of the file to be downloaded.
     *
     * @returns - A promise which resolves to the file contents.
     */
    FileBrowserModel.prototype.download = function (path) {
        var normalizePath = Private.normalizePath;
        path = normalizePath(this._model.path, path);
        return this._contentsManager.get(path, {}).then(function (contents) {
            var element = document.createElement('a');
            element.setAttribute('href', 'data:text/text;charset=utf-8,' + encodeURI(contents.content));
            element.setAttribute('download', contents.name);
            element.click();
            return contents;
        });
    };
    /**
     * Create a new untitled file or directory in the current directory.
     *
     * @param type - The type of file object to create. One of
     *  `['file', 'notebook', 'directory']`.
     *
     * @param ext - Optional extension for `'file'` types (defaults to `'.txt'`).
     *
     * @returns A promise containing the new file contents model.
     */
    FileBrowserModel.prototype.newUntitled = function (type, ext) {
        var _this = this;
        if (type === 'file') {
            ext = ext || '.txt';
        }
        else {
            ext = '';
        }
        return this._contentsManager.newUntitled(this._model.path, { type: type, ext: ext }).then(function (contents) {
            _this.fileChanged.emit({
                name: 'file',
                oldValue: void 0,
                newValue: contents.path
            });
            return contents;
        });
    };
    /**
     * Rename a file or directory.
     *
     * @param path - The path to the original file.
     *
     * @param newPath - The path to the new file.
     *
     * @returns A promise containing the new file contents model.
     */
    FileBrowserModel.prototype.rename = function (path, newPath) {
        var _this = this;
        // Handle relative paths.
        var normalizePath = Private.normalizePath;
        path = normalizePath(this._model.path, path);
        newPath = normalizePath(this._model.path, newPath);
        return this._contentsManager.rename(path, newPath).then(function (contents) {
            _this.fileChanged.emit({
                name: 'file',
                oldValue: path,
                newValue: newPath
            });
            return contents;
        });
    };
    /**
     * Upload a `File` object.
     *
     * @param file - The `File` object to upload.
     *
     * @param overwrite - Whether to overwrite an existing file.
     *
     * @returns A promise containing the new file contents model.
     *
     * #### Notes
     * This will fail to upload files that are too big to be sent in one
     * request to the server.
     */
    FileBrowserModel.prototype.upload = function (file, overwrite) {
        var _this = this;
        // Skip large files with a warning.
        if (file.size > this._maxUploadSizeMb * 1024 * 1024) {
            var msg = "Cannot upload file (>" + this._maxUploadSizeMb + " MB) ";
            msg += "\"" + file.name + "\"";
            console.warn(msg);
            return Promise.reject(new Error(msg));
        }
        if (overwrite) {
            return this._upload(file);
        }
        return this._contentsManager.get(file.name, {}).then(function () {
            return Private.typedThrow("\"" + file.name + "\" already exists");
        }, function () {
            return _this._upload(file);
        });
    };
    /**
     * Shut down a notebook session by session id.
     */
    FileBrowserModel.prototype.shutdown = function (sessionId) {
        return this._sessionManager.connectTo(sessionId.id).then(function (session) {
            return session.shutdown();
        });
    };
    /**
     * Start a new session on a notebook.
     */
    FileBrowserModel.prototype.startSession = function (path, kernel) {
        return this._sessionManager.startNew({
            notebookPath: path,
            kernelName: kernel
        });
    };
    /**
     * Sort the model items.
     */
    FileBrowserModel.prototype._sort = function () {
        var _this = this;
        if (!this._unsortedNames) {
            return;
        }
        var items = this._model.content.slice();
        if (this._sortKey === 'name') {
            items.sort(function (a, b) {
                var indexA = _this._unsortedNames.indexOf(a.name);
                var indexB = _this._unsortedNames.indexOf(b.name);
                return indexA - indexB;
            });
        }
        else if (this._sortKey === 'last_modified') {
            items.sort(function (a, b) {
                var valA = new Date(a.last_modified).getTime();
                var valB = new Date(b.last_modified).getTime();
                return valB - valA;
            });
        }
        // Reverse the order if descending.
        if (!this._ascending) {
            items.reverse();
        }
        this._model.content = items;
    };
    /**
     * Perform the actual upload.
     */
    FileBrowserModel.prototype._upload = function (file) {
        var _this = this;
        // Gather the file model parameters.
        var path = this._model.path;
        path = path ? path + '/' + file.name : file.name;
        var name = file.name;
        var isNotebook = file.name.indexOf('.ipynb') !== -1;
        var type = isNotebook ? 'notebook' : 'file';
        var format = isNotebook ? 'json' : 'base64';
        // Get the file content.
        var reader = new FileReader();
        if (isNotebook) {
            reader.readAsText(file);
        }
        else {
            reader.readAsArrayBuffer(file);
        }
        return new Promise(function (resolve, reject) {
            reader.onload = function (event) {
                var model = {
                    type: type,
                    format: format,
                    name: name,
                    content: Private.getContent(reader)
                };
                _this._contentsManager.save(path, model).then(function (contents) {
                    _this.fileChanged.emit({
                        name: 'file',
                        oldValue: void 0,
                        newValue: contents.path
                    });
                    resolve(contents);
                });
            };
            reader.onerror = function (event) {
                reject(Error(("Failed to upload \"" + file.name + "\":") + event));
            };
        });
    };
    /**
     * Get the notebook sessions for the current directory.
     */
    FileBrowserModel.prototype._findSessions = function () {
        var _this = this;
        this._sessionIds = [];
        var notebooks = this._model.content.filter(function (content) { return content.type === 'notebook'; });
        if (!notebooks.length) {
            return Promise.resolve(void 0);
        }
        return this._sessionManager.listRunning().then(function (sessionIds) {
            if (!sessionIds.length) {
                return;
            }
            var paths = notebooks.map(function (notebook) {
                return notebook.path;
            });
            for (var _i = 0, sessionIds_1 = sessionIds; _i < sessionIds_1.length; _i++) {
                var sessionId = sessionIds_1[_i];
                var index = paths.indexOf(sessionId.notebook.path);
                if (index !== -1) {
                    _this._sessionIds.push(sessionId);
                }
            }
        });
    };
    return FileBrowserModel;
}());
exports.FileBrowserModel = FileBrowserModel;
/**
 * The namespace for the file browser model private data.
 */
var Private;
(function (Private) {
    /**
     * A signal emitted when a model refresh occurs.
     */
    Private.refreshedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the a file changes path.
     */
    Private.fileChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the selection changes.
     */
    Private.selectionChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * Parse the content of a `FileReader`.
     *
     * If the result is an `ArrayBuffer`, return a Base64-encoded string.
     * Otherwise, return the JSON parsed result.
     */
    function getContent(reader) {
        if (reader.result instanceof ArrayBuffer) {
            // Base64-encode binary file data.
            var bytes = '';
            var buf = new Uint8Array(reader.result);
            var nbytes = buf.byteLength;
            for (var i = 0; i < nbytes; i++) {
                bytes += String.fromCharCode(buf[i]);
            }
            return btoa(bytes);
        }
        else {
            return JSON.parse(reader.result);
        }
    }
    Private.getContent = getContent;
    /**
     * Normalize a path based on a root directory, accounting for relative paths.
     */
    function normalizePath(root, path) {
        // Current directory
        if (path === '.') {
            return root;
        }
        // Root path.
        if (path.indexOf('/') === 0) {
            path = path.slice(1, path.length);
            root = '';
        }
        else if (path.indexOf('./') === 0) {
            path = path.slice(2, path.length);
        }
        else if (path.indexOf('../../') === 0) {
            var parts = root.split('/');
            root = parts.splice(0, parts.length - 2).join('/');
            path = path.slice(6, path.length);
        }
        else if (path.indexOf('../') === 0) {
            var parts = root.split('/');
            root = parts.splice(0, parts.length - 1).join('/');
            path = path.slice(3, path.length);
        }
        else {
        }
        if (path[path.length - 1] === '/') {
            path = path.slice(0, path.length - 1);
        }
        // Combine the root and the path if necessary.
        if (root && path) {
            path = root + '/' + path;
        }
        else if (root) {
            path = root;
        }
        return path;
    }
    Private.normalizePath = normalizePath;
    /**
     * Work around TS 1.8 type inferencing in promises which only throw.
     */
    function typedThrow(msg) {
        throw new Error(msg);
    }
    Private.typedThrow = typedThrow;
})(Private || (Private = {}));
