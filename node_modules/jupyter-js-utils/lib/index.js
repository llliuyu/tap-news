// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
'use strict';
var minimist = require('minimist');
/**
 * Copy the contents of one object to another, recursively.
 *
 * From [stackoverflow](http://stackoverflow.com/a/12317051).
 */
function extend(target, source) {
    target = target || {};
    for (var prop in source) {
        if (typeof source[prop] === 'object') {
            target[prop] = extend(target[prop], source[prop]);
        }
        else {
            target[prop] = source[prop];
        }
    }
    return target;
}
exports.extend = extend;
/**
 * Get a copy of an object, or null.
 */
function copy(object) {
    if (object !== null && typeof object === 'object') {
        return JSON.parse(JSON.stringify(object));
    }
    return null;
}
exports.copy = copy;
/**
 * Check for shallow equality of two objects.
 */
function shallowEquals(o1, o2) {
    for (var p in o1) {
        if (o1.hasOwnProperty(p)) {
            if (o1[p] !== o2[p]) {
                return false;
            }
        }
    }
    for (var p in o2) {
        if (o2.hasOwnProperty(p) && !o1.hasOwnProperty(p)) {
            return false;
        }
    }
    return true;
}
exports.shallowEquals = shallowEquals;
;
/**
 * Get a random 32 character hex string (not a formal UUID)
 */
function uuid() {
    var s = [];
    var hexDigits = "0123456789abcdef";
    var nChars = hexDigits.length;
    for (var i = 0; i < 32; i++) {
        s[i] = hexDigits.charAt(Math.floor(Math.random() * nChars));
    }
    return s.join("");
}
exports.uuid = uuid;
/**
 * Join a sequence of url components with `'/'`.
 */
function urlPathJoin() {
    var paths = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        paths[_i - 0] = arguments[_i];
    }
    var url = '';
    for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        if (path === '') {
            continue;
        }
        if (i > 0) {
            path = path.replace(/\/\/+/, '/');
        }
        if (url.length > 0 && url.charAt(url.length - 1) != '/' && path[0] != '/') {
            url = url + '/' + path;
        }
        else {
            url = url + path;
        }
    }
    return url;
}
exports.urlPathJoin = urlPathJoin;
/**
 * Encode just the components of a multi-segment uri.
 *
 * Preserves the `'/'` separators.
 */
function encodeURIComponents(uri) {
    return uri.split('/').map(encodeURIComponent).join('/');
}
exports.encodeURIComponents = encodeURIComponents;
/**
 * Encode and join a sequence of url components with `'/'`.
 */
function urlJoinEncode() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return encodeURIComponents(urlPathJoin.apply(null, args));
}
exports.urlJoinEncode = urlJoinEncode;
/**
 * Return a serialized object string suitable for a query.
 *
 * From [stackoverflow](http://stackoverflow.com/a/30707423).
 */
function jsonToQueryString(json) {
    return '?' + Object.keys(json).map(function (key) {
        return encodeURIComponent(key) + '=' + encodeURIComponent(json[key]);
    }).join('&');
}
exports.jsonToQueryString = jsonToQueryString;
/**
 * Asynchronous XMLHTTPRequest handler.
 *
 * @param url - The url to request.
 *
 * @param settings - The settings to apply to the request and response.
 *
 * #### Notes
 * Based on this [example](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promisifying-xmlhttprequest).
 */
function ajaxRequest(url, settings) {
    var method = settings.method || 'GET';
    var user = settings.user || '';
    var password = settings.password || '';
    if (!settings.cache) {
        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache.
        url += ((/\?/).test(url) ? "&" : "?") + (new Date()).getTime();
    }
    return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();
        req.open(method, url, true, user, password);
        if (settings.contentType !== void 0) {
            req.setRequestHeader('Content-Type', settings.contentType);
        }
        if (settings.timeout !== void 0)
            req.timeout = settings.timeout;
        if (!!settings.withCredentials) {
            req.withCredentials = true;
        }
        if (settings.requestHeaders !== void 0) {
            for (var prop in settings.requestHeaders) {
                req.setRequestHeader(prop, settings.requestHeaders[prop]);
            }
        }
        req.onload = function () {
            if (req.status >= 400) {
                var error = new Error(req.statusText);
                reject({ xhr: req, statusText: req.statusText, error: error });
                return;
            }
            var response = req.responseText;
            if (settings.dataType === 'json' && response) {
                response = JSON.parse(response);
            }
            resolve({ data: response, statusText: req.statusText, xhr: req });
        };
        req.onerror = function (err) {
            reject({ xhr: req, statusText: req.statusText, error: err });
        };
        req.ontimeout = function () {
            reject({ xhr: req, statusText: req.statusText,
                error: new Error('Operation Timed Out') });
        };
        if (settings.data) {
            req.send(settings.data);
        }
        else {
            req.send();
        }
    });
}
exports.ajaxRequest = ajaxRequest;
/**
 * Try to load an object from a module or a registry.
 *
 * Try to load an object from a module asynchronously if a module
 * is specified, otherwise tries to load an object from the global
 * registry, if the global registry is provided.
 */
function loadObject(name, moduleName, registry) {
    return new Promise(function (resolve, reject) {
        // Try loading the view module using require.js
        if (moduleName) {
            if (typeof requirejs === 'undefined') {
                throw new Error('requirejs not found.');
            }
            requirejs([moduleName], function (mod) {
                if (mod[name] === void 0) {
                    var msg = "Object '" + name + "' not found in module '" + moduleName + "'";
                    reject(new Error(msg));
                }
                else {
                    resolve(mod[name]);
                }
            }, reject);
        }
        else {
            if (registry && registry[name]) {
                resolve(registry[name]);
            }
            else {
                reject(new Error("Object '" + name + "' not found in registry"));
            }
        }
    });
}
exports.loadObject = loadObject;
;
/**
 * A Promise that can be resolved or rejected by another object.
 */
var PromiseDelegate = (function () {
    /**
     * Construct a new Promise delegate.
     */
    function PromiseDelegate() {
        var _this = this;
        this._promise = new Promise(function (resolve, reject) {
            _this._resolve = resolve;
            _this._reject = reject;
        });
    }
    Object.defineProperty(PromiseDelegate.prototype, "promise", {
        /**
         * Get the underlying Promise.
         */
        get: function () {
            return this._promise;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolve the underlying Promise with an optional value or another Promise.
     */
    PromiseDelegate.prototype.resolve = function (value) {
        // Note: according to the Promise spec, and the `this` context for resolve
        // and reject are ignored
        this._resolve(value);
    };
    /**
     * Reject the underlying Promise with an optional reason.
     */
    PromiseDelegate.prototype.reject = function (reason) {
        // Note: according to the Promise spec, the `this` context for resolve
        // and reject are ignored
        this._reject(reason);
    };
    return PromiseDelegate;
})();
exports.PromiseDelegate = PromiseDelegate;
/**
 * Global config data for the Jupyter application.
 */
var configData = null;
/**
 *  Make an object fully immutable by freezing each object in it.
 */
function deepFreeze(obj) {
    // Freeze properties before freezing self
    Object.getOwnPropertyNames(obj).forEach(function (name) {
        var prop = obj[name];
        // Freeze prop if it is an object
        if (typeof prop == 'object' && prop !== null && !Object.isFrozen(prop))
            deepFreeze(prop);
    });
    // Freeze self
    return Object.freeze(obj);
}
function getConfigOption(name) {
    if (configData) {
        return configData[name];
    }
    if (typeof document === 'undefined') {
        configData = minimist(process.argv.slice(2));
    }
    else {
        var el = document.getElementById('jupyter-config-data');
        if (el) {
            configData = JSON.parse(el.textContent);
        }
        else {
            configData = {};
        }
    }
    configData = deepFreeze(configData);
    return configData[name];
}
exports.getConfigOption = getConfigOption;
/**
 * Get the base URL for a Jupyter application.
 */
function getBaseUrl() {
    var baseUrl = getConfigOption('baseUrl');
    if (!baseUrl || baseUrl === '/') {
        baseUrl = (typeof location === 'undefined' ?
            'http://localhost:8888/' : location.origin + '/');
    }
    return baseUrl;
}
exports.getBaseUrl = getBaseUrl;
/**
 * Get the base websocket URL for a Jupyter application.
 */
function getWsUrl(baseUrl) {
    var wsUrl = getConfigOption('wsUrl');
    if (!wsUrl) {
        baseUrl = baseUrl || getBaseUrl();
        if (baseUrl.indexOf('http') !== 0) {
            if (typeof location !== 'undefined') {
                baseUrl = urlPathJoin(location.origin, baseUrl);
            }
            else {
                baseUrl = urlPathJoin('http://localhost:8888/', baseUrl);
            }
        }
        wsUrl = 'ws' + baseUrl.slice(4);
    }
    return wsUrl;
}
exports.getWsUrl = getWsUrl;
//# sourceMappingURL=index.js.map