/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_nodewrapper_1 = require('phosphor-nodewrapper');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var title_1 = require('./title');
/**
 * The class name added to Widget instances.
 */
var WIDGET_CLASS = 'p-Widget';
/**
 * The class name added to hidden widgets.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The base class of the Phosphor widget hierarchy.
 *
 * #### Notes
 * This class will typically be subclassed in order to create a useful
 * widget. However, it can be used directly to host externally created
 * content. Simply instantiate an empty widget and add the DOM content
 * directly to the widget's `.node`.
 */
var Widget = (function (_super) {
    __extends(Widget, _super);
    /**
     * Construct a new widget.
     */
    function Widget() {
        _super.call(this);
        this._flags = 0;
        this._layout = null;
        this._parent = null;
        this.addClass(WIDGET_CLASS);
    }
    /**
     * Dispose of the widget and its descendants.
     *
     * #### Notes
     * It is generally unsafe to use the widget after it is disposed.
     *
     * All calls made to this method after the first are a no-op.
     */
    Widget.prototype.dispose = function () {
        // Do nothing if the widget is already disposed.
        if (this.isDisposed) {
            return;
        }
        // Set the disposed flag and emit the disposed signal.
        this.setFlag(WidgetFlag.IsDisposed);
        this.disposed.emit(void 0);
        // Remove or detach the widget if necessary.
        if (this.parent) {
            this.parent = null;
        }
        else if (this.isAttached) {
            this.detach();
        }
        // Dispose of the widget layout.
        if (this._layout) {
            this._layout.dispose();
            this._layout = null;
        }
        // Clear the attached data associated with the widget.
        phosphor_signaling_1.clearSignalData(this);
        phosphor_messaging_1.clearMessageData(this);
        phosphor_properties_1.clearPropertyData(this);
    };
    Object.defineProperty(Widget.prototype, "disposed", {
        /**
         * A signal emitted when the widget is disposed.
         *
         * **See also:** [[dispose]], [[disposed]]
         */
        get: function () {
            return WidgetPrivate.disposedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "isDisposed", {
        /**
         * Test whether the widget has been disposed.
         *
         * #### Notes
         * This is a read-only property.
         *
         * **See also:** [[dispose]], [[disposed]]
         */
        get: function () {
            return this.testFlag(WidgetFlag.IsDisposed);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "isAttached", {
        /**
         * Test whether the widget's node is attached to the DOM.
         *
         * #### Notes
         * This is a read-only property.
         *
         * **See also:** [[attach]], [[detach]]
         */
        get: function () {
            return this.testFlag(WidgetFlag.IsAttached);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "isHidden", {
        /**
         * Test whether the widget is explicitly hidden.
         *
         * #### Notes
         * This is a read-only property.
         *
         * **See also:** [[isVisible]], [[hide]], [[show]]
         */
        get: function () {
            return this.testFlag(WidgetFlag.IsHidden);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "isVisible", {
        /**
         * Test whether the widget is visible.
         *
         * #### Notes
         * A widget is visible when it is attached to the DOM, is not
         * explicitly hidden, and has no explicitly hidden ancestors.
         *
         * This is a read-only property.
         *
         * **See also:** [[isHidden]], [[hide]], [[show]]
         */
        get: function () {
            return this.testFlag(WidgetFlag.IsVisible);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "title", {
        /**
         * Get the title data object for the widget.
         *
         * #### Notes
         * The title data is used by some container widgets when displaying
         * the widget along with a title, such as a tab panel or dock panel.
         *
         * Not all widgets will make use of the title data, so it is created
         * on-demand the first time it is accessed.
         */
        get: function () {
            return WidgetPrivate.titleProperty.get(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "parent", {
        /**
         * Get the parent of the widget.
         *
         * #### Notes
         * This will be `null` if the widget does not have a parent.
         */
        get: function () {
            return this._parent;
        },
        /**
         * Set the parent of the widget.
         *
         * #### Notes
         * The widget will be automatically removed from its current parent.
         *
         * This is a no-op if there is no effective parent change.
         */
        set: function (value) {
            value = value || null;
            if (this._parent === value) {
                return;
            }
            if (value && this.contains(value)) {
                throw new Error('Invalid parent widget.');
            }
            if (this._parent && !this._parent.isDisposed) {
                phosphor_messaging_1.sendMessage(this._parent, new ChildMessage('child-removed', this));
            }
            this._parent = value;
            if (this._parent && !this._parent.isDisposed) {
                phosphor_messaging_1.sendMessage(this._parent, new ChildMessage('child-added', this));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "layout", {
        /**
         * Get the layout for the widget.
         *
         * #### Notes
         * This will be `null` if the widget does not have a layout.
         */
        get: function () {
            return this._layout;
        },
        /**
         * Set the layout for the widget.
         *
         * #### Notes
         * The layout is single-use only. It cannot be set to `null` and it
         * cannot be changed after the first assignment.
         *
         * The layout is disposed automatically when the widget is disposed.
         */
        set: function (value) {
            if (!value) {
                throw new Error('Cannot set widget layout to null.');
            }
            if (this._layout === value) {
                return;
            }
            if (this._layout) {
                throw new Error('Cannot change widget layout.');
            }
            if (value.parent) {
                throw new Error('Cannot change layout parent.');
            }
            this._layout = value;
            value.parent = this;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Test whether a widget is a descendant of this widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns `true` if the widget is a descendant, `false` otherwise.
     */
    Widget.prototype.contains = function (widget) {
        while (widget) {
            if (widget === this) {
                return true;
            }
            widget = widget._parent;
        }
        return false;
    };
    /**
     * Post an `'update-request'` message to the widget.
     *
     * **See also:** [[MsgUpdateRequest]]
     */
    Widget.prototype.update = function () {
        phosphor_messaging_1.postMessage(this, Widget.MsgUpdateRequest);
    };
    /**
     * Post a `'fit-request'` message to the widget.
     *
     * **See also:** [[MsgFitRequest]]
     */
    Widget.prototype.fit = function () {
        phosphor_messaging_1.postMessage(this, Widget.MsgFitRequest);
    };
    /**
     * Send a `'close-request'` message to the widget.
     *
     * **See also:** [[MsgCloseRequest]]
     */
    Widget.prototype.close = function () {
        phosphor_messaging_1.sendMessage(this, Widget.MsgCloseRequest);
    };
    /**
     * Show the widget and make it visible to its parent widget.
     *
     * #### Notes
     * This causes the [[isHidden]] property to be `false`.
     */
    Widget.prototype.show = function () {
        if (!this.testFlag(WidgetFlag.IsHidden)) {
            return;
        }
        this.clearFlag(WidgetFlag.IsHidden);
        this.removeClass(HIDDEN_CLASS);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
            phosphor_messaging_1.sendMessage(this, Widget.MsgAfterShow);
        }
        if (this.parent) {
            phosphor_messaging_1.sendMessage(this.parent, new ChildMessage('child-shown', this));
        }
    };
    /**
     * Hide the widget and make it hidden to its parent widget.
     *
     * #### Notes
     * This causes the [[isHidden]] property to be `true`.
     */
    Widget.prototype.hide = function () {
        if (this.testFlag(WidgetFlag.IsHidden)) {
            return;
        }
        this.setFlag(WidgetFlag.IsHidden);
        if (this.isAttached && (!this.parent || this.parent.isVisible)) {
            phosphor_messaging_1.sendMessage(this, Widget.MsgBeforeHide);
        }
        this.addClass(HIDDEN_CLASS);
        if (this.parent) {
            phosphor_messaging_1.sendMessage(this.parent, new ChildMessage('child-hidden', this));
        }
    };
    /**
     * Set whether the widget is hidden.
     *
     * @param hidden - `true` to hide the widget, or `false` to show it.
     *
     * #### Notes
     * `widget.setHidden(true)` is equivalent to `widget.hide()`, and
     * `widget.setHidden(false)` is equivalent to `widget.show()`.
     */
    Widget.prototype.setHidden = function (hidden) {
        if (hidden) {
            this.hide();
        }
        else {
            this.show();
        }
    };
    /**
     * Attach the widget to a host DOM node.
     *
     * @param host - The DOM node to use as the widget's host.
     *
     * @throws An error if the widget is not a root widget, if the widget
     *   is already attached, or if the host is not attached to the DOM.
     */
    Widget.prototype.attach = function (host) {
        if (this.parent) {
            throw new Error('Cannot attach child widget.');
        }
        if (this.isAttached || document.body.contains(this.node)) {
            throw new Error('Widget already attached.');
        }
        if (!document.body.contains(host)) {
            throw new Error('Host not attached.');
        }
        host.appendChild(this.node);
        phosphor_messaging_1.sendMessage(this, Widget.MsgAfterAttach);
    };
    /**
     * Detach the widget from its host DOM node.
     *
     * @throws An error if the widget is not a root widget, or if the
     *   widget is not attached.
     */
    Widget.prototype.detach = function () {
        if (this.parent) {
            throw new Error('Cannot detach child widget.');
        }
        if (!this.isAttached || !document.body.contains(this.node)) {
            throw new Error('Widget not attached.');
        }
        phosphor_messaging_1.sendMessage(this, Widget.MsgBeforeDetach);
        this.node.parentNode.removeChild(this.node);
    };
    /**
     * Test whether the given widget flag is set.
     *
     * #### Notes
     * This will not typically be consumed directly by user code.
     */
    Widget.prototype.testFlag = function (flag) {
        return (this._flags & flag) !== 0;
    };
    /**
     * Set the given widget flag.
     *
     * #### Notes
     * This will not typically be consumed directly by user code.
     */
    Widget.prototype.setFlag = function (flag) {
        this._flags |= flag;
    };
    /**
     * Clear the given widget flag.
     *
     * #### Notes
     * This will not typically be consumed directly by user code.
     */
    Widget.prototype.clearFlag = function (flag) {
        this._flags &= ~flag;
    };
    /**
     * Compress a message posted to the widget.
     *
     * @param msg - The message posted to the widget.
     *
     * @param pending - The queue of pending messages for the widget.
     *
     * @returns `true` if the message should be ignored, or `false` if
     *   the message should be enqueued for delivery as normal.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    Widget.prototype.compressMessage = function (msg, pending) {
        if (msg.type === 'update-request') {
            return pending.some(function (other) { return other.type === 'update-request'; });
        }
        if (msg.type === 'fit-request') {
            return pending.some(function (other) { return other.type === 'fit-request'; });
        }
        return false;
    };
    /**
     * Process a message sent to the widget.
     *
     * @param msg - The message sent to the widget.
     *
     * #### Notes
     * Subclasses may reimplement this method as needed.
     */
    Widget.prototype.processMessage = function (msg) {
        switch (msg.type) {
            case 'resize':
                this.notifyLayout(msg);
                this.onResize(msg);
                break;
            case 'update-request':
                this.notifyLayout(msg);
                this.onUpdateRequest(msg);
                break;
            case 'after-show':
                this.setFlag(WidgetFlag.IsVisible);
                this.notifyLayout(msg);
                this.onAfterShow(msg);
                break;
            case 'before-hide':
                this.notifyLayout(msg);
                this.onBeforeHide(msg);
                this.clearFlag(WidgetFlag.IsVisible);
                break;
            case 'after-attach':
                var visible = !this.isHidden && (!this.parent || this.parent.isVisible);
                if (visible)
                    this.setFlag(WidgetFlag.IsVisible);
                this.setFlag(WidgetFlag.IsAttached);
                this.notifyLayout(msg);
                this.onAfterAttach(msg);
                break;
            case 'before-detach':
                this.notifyLayout(msg);
                this.onBeforeDetach(msg);
                this.clearFlag(WidgetFlag.IsVisible);
                this.clearFlag(WidgetFlag.IsAttached);
                break;
            case 'close-request':
                this.notifyLayout(msg);
                this.onCloseRequest(msg);
                break;
            case 'child-added':
                this.notifyLayout(msg);
                this.onChildAdded(msg);
                break;
            case 'child-removed':
                this.notifyLayout(msg);
                this.onChildRemoved(msg);
                break;
            default:
                this.notifyLayout(msg);
                break;
        }
    };
    /**
     * Invoke the message processing routine of the widget's layout.
     *
     * @param msg - The message to dispatch to the layout.
     *
     * #### Notes
     * This is a no-op if the widget does not have a layout.
     */
    Widget.prototype.notifyLayout = function (msg) {
        if (this.layout)
            this.layout.processParentMessage(msg);
    };
    /**
     * A message handler invoked on a `'close-request'` message.
     *
     * #### Notes
     * The default implementation of this handler detaches the widget.
     *
     * **See also:** [[close]], [[MsgCloseRequest]]
     */
    Widget.prototype.onCloseRequest = function (msg) {
        if (this.parent) {
            this.parent = null;
        }
        else if (this.isAttached) {
            this.detach();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[ResizeMessage]]
     */
    Widget.prototype.onResize = function (msg) { };
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[update]], [[MsgUpdateRequest]]
     */
    Widget.prototype.onUpdateRequest = function (msg) { };
    /**
     * A message handler invoked on an `'after-show'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[MsgAfterShow]]
     */
    Widget.prototype.onAfterShow = function (msg) { };
    /**
     * A message handler invoked on a `'before-hide'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[MsgBeforeHide]]
     */
    Widget.prototype.onBeforeHide = function (msg) { };
    /**
     * A message handler invoked on an `'after-attach'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[MsgAfterAttach]]
     */
    Widget.prototype.onAfterAttach = function (msg) { };
    /**
     * A message handler invoked on a `'before-detach'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[MsgBeforeDetach]]
     */
    Widget.prototype.onBeforeDetach = function (msg) { };
    /**
     * A message handler invoked on a `'child-added'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[ChildMessage]]
     */
    Widget.prototype.onChildAdded = function (msg) { };
    /**
     * A message handler invoked on a `'child-removed'` message.
     *
     * The default implementation of this handler is a no-op.
     *
     * **See also:** [[ChildMessage]]
     */
    Widget.prototype.onChildRemoved = function (msg) { };
    return Widget;
})(phosphor_nodewrapper_1.NodeWrapper);
exports.Widget = Widget;
/**
 * The namespace for the `Widget` class statics.
 */
var Widget;
(function (Widget) {
    /**
     * A singleton `'update-request'` message.
     *
     * #### Notes
     * This message can be dispatched to supporting widgets in order to
     * update their content based on the current widget state. Not all
     * widgets will respond to messages of this type.
     *
     * For widgets with a layout, this message will inform the layout to
     * update the position and size of its child widgets.
     *
     * Messages of this type are compressed by default.
     *
     * **See also:** [[update]], [[onUpdateRequest]]
     */
    Widget.MsgUpdateRequest = new phosphor_messaging_1.Message('update-request');
    /**
     * A singleton `'fit-request'` message.
     *
     * #### Notes
     * For widgets with a layout, this message will inform the layout to
     * recalculate its size constraints to fit the space requirements of
     * its child widgets, and to update their position and size. Not all
     * layouts will respond to messages of this type.
     *
     * Messages of this type are compressed by default.
     *
     * **See also:** [[fit]]
     */
    Widget.MsgFitRequest = new phosphor_messaging_1.Message('fit-request');
    /**
     * A singleton `'close-request'` message.
     *
     * #### Notes
     * This message should be dispatched to a widget when it should close
     * and remove itself from the widget hierarchy.
     *
     * Messages of this type are compressed by default.
     *
     * **See also:** [[close]], [[onCloseRequest]]
     */
    Widget.MsgCloseRequest = new phosphor_messaging_1.Message('close-request');
    /**
     * A singleton `'after-show'` message.
     *
     * #### Notes
     * This message is sent to a widget after it becomes visible.
     *
     * This message is **not** sent when the widget is being attached.
     *
     * **See also:** [[isVisible]], [[onAfterShow]]
     */
    Widget.MsgAfterShow = new phosphor_messaging_1.Message('after-show');
    /**
     * A singleton `'before-hide'` message.
     *
     * #### Notes
     * This message is sent to a widget before it becomes not-visible.
     *
     * This message is **not** sent when the widget is being detached.
     *
     * **See also:** [[isVisible]], [[onBeforeHide]]
     */
    Widget.MsgBeforeHide = new phosphor_messaging_1.Message('before-hide');
    /**
     * A singleton `'after-attach'` message.
     *
     * #### Notes
     * This message is sent to a widget after it is attached.
     *
     * **See also:** [[isAttached]], [[onAfterAttach]]
     */
    Widget.MsgAfterAttach = new phosphor_messaging_1.Message('after-attach');
    /**
     * A singleton `'before-detach'` message.
     *
     * #### Notes
     * This message is sent to a widget before it is detached.
     *
     * **See also:** [[isAttached]], [[onBeforeDetach]]
     */
    Widget.MsgBeforeDetach = new phosphor_messaging_1.Message('before-detach');
})(Widget = exports.Widget || (exports.Widget = {}));
/**
 * An enum of widget bit flags.
 */
(function (WidgetFlag) {
    /**
     * The widget has been disposed.
     */
    WidgetFlag[WidgetFlag["IsDisposed"] = 1] = "IsDisposed";
    /**
     * The widget is attached to the DOM.
     */
    WidgetFlag[WidgetFlag["IsAttached"] = 2] = "IsAttached";
    /**
     * The widget is hidden.
     */
    WidgetFlag[WidgetFlag["IsHidden"] = 4] = "IsHidden";
    /**
     * The widget is visible.
     */
    WidgetFlag[WidgetFlag["IsVisible"] = 8] = "IsVisible";
})(exports.WidgetFlag || (exports.WidgetFlag = {}));
var WidgetFlag = exports.WidgetFlag;
/**
 * A message class for child related messages.
 */
var ChildMessage = (function (_super) {
    __extends(ChildMessage, _super);
    /**
     * Construct a new child message.
     *
     * @param type - The message type.
     *
     * @param child - The child widget for the message.
     */
    function ChildMessage(type, child) {
        _super.call(this, type);
        this._child = child;
    }
    Object.defineProperty(ChildMessage.prototype, "child", {
        /**
         * The child widget for the message.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._child;
        },
        enumerable: true,
        configurable: true
    });
    return ChildMessage;
})(phosphor_messaging_1.Message);
exports.ChildMessage = ChildMessage;
/**
 * A message class for `'resize'` messages.
 */
var ResizeMessage = (function (_super) {
    __extends(ResizeMessage, _super);
    /**
     * Construct a new resize message.
     *
     * @param width - The **offset width** of the widget, or `-1` if
     *   the width is not known.
     *
     * @param height - The **offset height** of the widget, or `-1` if
     *   the height is not known.
     */
    function ResizeMessage(width, height) {
        _super.call(this, 'resize');
        this._width = width;
        this._height = height;
    }
    Object.defineProperty(ResizeMessage.prototype, "width", {
        /**
         * The offset width of the widget.
         *
         * #### Notes
         * This will be `-1` if the width is unknown.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResizeMessage.prototype, "height", {
        /**
         * The offset height of the widget.
         *
         * #### Notes
         * This will be `-1` if the height is unknown.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    return ResizeMessage;
})(phosphor_messaging_1.Message);
exports.ResizeMessage = ResizeMessage;
/**
 * The namespace for the `ResizeMessage` class statics.
 */
var ResizeMessage;
(function (ResizeMessage) {
    /**
     * A singleton `'resize'` message with an unknown size.
     */
    ResizeMessage.UnknownSize = new ResizeMessage(-1, -1);
})(ResizeMessage = exports.ResizeMessage || (exports.ResizeMessage = {}));
/**
 * The namespace for the widget private data.
 */
var WidgetPrivate;
(function (WidgetPrivate) {
    /**
     * A signal emitted when the widget is disposed.
     */
    WidgetPrivate.disposedSignal = new phosphor_signaling_1.Signal();
    /**
     * A property for the title data for a widget.
     */
    WidgetPrivate.titleProperty = new phosphor_properties_1.Property({
        name: 'title',
        create: function () { return new title_1.Title(); },
    });
})(WidgetPrivate || (WidgetPrivate = {}));
