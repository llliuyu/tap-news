/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var widget_1 = require('./widget');
/**
 * The abstract base class of all Phosphor layouts.
 *
 * #### Notes
 * A layout is used to add child widgets to a parent and to arrange
 * those children within the parent's node.
 *
 * This class must be subclassed to make a fully functioning layout.
 */
var Layout = (function () {
    function Layout() {
        this._disposed = false;
        this._parent = null;
    }
    /**
     * Dispose of the resources held by the layout.
     *
     * #### Notes
     * This method should be reimplemented by subclasses to dispose their
     * children. All reimplementations should call the superclass method.
     */
    Layout.prototype.dispose = function () {
        this._disposed = true;
        this._parent = null;
        phosphor_signaling_1.clearSignalData(this);
        phosphor_properties_1.clearPropertyData(this);
    };
    Object.defineProperty(Layout.prototype, "isDisposed", {
        /**
         * Test whether the layout is disposed.
         *
         * #### Notes
         * This is a read-only property.
         */
        get: function () {
            return this._disposed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Layout.prototype, "parent", {
        /**
         * Get the parent widget of the layout.
         */
        get: function () {
            return this._parent;
        },
        /**
         * Set the parent widget of the layout.
         *
         * #### Notes
         * This is set automatically when installing the layout on the parent
         * widget. The layout parent should not be set directly by user code.
         */
        set: function (value) {
            if (!value) {
                throw new Error('Cannot set layout parent to null.');
            }
            if (this._parent === value) {
                return;
            }
            if (this._parent) {
                throw new Error('Cannot change layout parent.');
            }
            if (value.layout !== this) {
                throw new Error('Invalid layout parent.');
            }
            this._parent = value;
            this.initialize();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Process a message sent to the parent widget.
     *
     * @param msg - The message sent to the parent widget.
     *
     * #### Notes
     * This method is called by the parent to process a message.
     *
     * Subclasses may reimplement this method as needed.
     */
    Layout.prototype.processParentMessage = function (msg) {
        switch (msg.type) {
            case 'resize':
                this.onResize(msg);
                break;
            case 'update-request':
                this.onUpdateRequest(msg);
                break;
            case 'fit-request':
                this.onFitRequest(msg);
                break;
            case 'after-attach':
                this.onAfterAttach(msg);
                break;
            case 'before-detach':
                this.onBeforeDetach(msg);
                break;
            case 'after-show':
                this.onAfterShow(msg);
                break;
            case 'before-hide':
                this.onBeforeHide(msg);
                break;
            case 'child-removed':
                this.onChildRemoved(msg);
                break;
            case 'child-shown':
                this.onChildShown(msg);
                break;
            case 'child-hidden':
                this.onChildHidden(msg);
                break;
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Layout.prototype.onFitRequest = function (msg) { };
    /**
     * A message handler invoked on a `'child-shown'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Layout.prototype.onChildShown = function (msg) { };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     *
     * The default implementation of this handler is a no-op.
     */
    Layout.prototype.onChildHidden = function (msg) { };
    return Layout;
})();
exports.Layout = Layout;
/**
 * An abstract base class for creating index-based layouts.
 *
 * #### Notes
 * This class implements core functionality which is required by nearly
 * all layouts. It is a good starting point for creating custom layouts
 * which control the types of children that may be added to the layout.
 *
 * This class must be subclassed to make a fully functioning layout.
 */
var AbstractLayout = (function (_super) {
    __extends(AbstractLayout, _super);
    function AbstractLayout() {
        _super.apply(this, arguments);
    }
    /**
     * Get the index of the specified child widget.
     *
     * @param child - The child widget of interest.
     *
     * @returns The index of the specified child, or `-1`.
     */
    AbstractLayout.prototype.childIndex = function (child) {
        for (var i = 0; i < this.childCount(); ++i) {
            if (this.childAt(i) === child)
                return i;
        }
        return -1;
    };
    /**
     * A message handler invoked on a `'resize'` message.
     *
     * #### Notes
     * The default implementation of this method sends an `UnknownSize`
     * resize message to all children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onResize = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            phosphor_messaging_1.sendMessage(this.childAt(i), widget_1.ResizeMessage.UnknownSize);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     *
     * #### Notes
     * The default implementation of this method sends an `UnknownSize`
     * resize message to all children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onUpdateRequest = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            phosphor_messaging_1.sendMessage(this.childAt(i), widget_1.ResizeMessage.UnknownSize);
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     *
     * #### Notes
     * The default implementation of this method forwards the message
     * to all children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onAfterAttach = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            phosphor_messaging_1.sendMessage(this.childAt(i), msg);
        }
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     *
     * #### Notes
     * The default implementation of this method forwards the message
     * to all children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onBeforeDetach = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            phosphor_messaging_1.sendMessage(this.childAt(i), msg);
        }
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     *
     * #### Notes
     * The default implementation of this method forwards the message
     * to all non-hidden children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onAfterShow = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            var child = this.childAt(i);
            if (!child.isHidden)
                phosphor_messaging_1.sendMessage(child, msg);
        }
    };
    /**
     * A message handler invoked on a `'before-hide'` message.
     *
     * #### Notes
     * The default implementation of this method forwards the message
     * to all non-hidden children.
     *
     * This may be reimplemented by subclasses as needed.
     */
    AbstractLayout.prototype.onBeforeHide = function (msg) {
        for (var i = 0; i < this.childCount(); ++i) {
            var child = this.childAt(i);
            if (!child.isHidden)
                phosphor_messaging_1.sendMessage(child, msg);
        }
    };
    return AbstractLayout;
})(Layout);
exports.AbstractLayout = AbstractLayout;
